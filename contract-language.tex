\section{Contract Language}
\label{sec:lang}

\begin{figure}
\begin{smathpar}
\begin{array}{rclcl}
\multicolumn{5}{l}{
  {x,y,z} \in \mathtt{EffVar} \qquad
  {\cureff} \in \mathtt{CurEff} \qquad
  {\sf Op} \in \mathtt{OperName}
}\\
\cv 		& \in & \mathtt{Contract} 	& \coloneqq & \forall (x : \tau).\cv
        \ALT \pi \\
\tau		& \in	& \mathtt{EffType}	& \coloneqq &  {\sf Op}
        \ALT \tau \vee \tau \\
\pi			&	\in & \mathtt{Prop} & \coloneqq & \true \ALT R(x,y)
        \ALT \pi \vee \pi \\
			  & 		&	 &  \ALT & \pi \wedge \pi \ALT \pi \Rightarrow \pi \\
R				& \in & \mathtt{Relation}	& \coloneqq & \visZ \ALT \soZ
        \ALT \sameobjZ \ALT R^+ \\
				&			&	 &  \ALT & R \cup R \ALT R \cap R \\
\end{array}
\end{smathpar}
\caption{Contract language.}
\label{fig:contract-lang}
\end{figure}


\subsection{Syntax}

The syntax of our core contract language is shown in Figure
~\ref{fig:contract-lang}. The language is based on first-order logic (FOL), and
admits prenex universal quantification over typed effect variables. We use a
special effect variable ($\cureff$) to denote the effect of \emph{current
operation} - the operation for which a contract is being written. The type of
an effect is simply the name of the operation (eg: \cf{withdraw}) that induced
the effect. We admit disjuntion in types to let an effect variable range over
multiple operation names. The contract $\small \forall (a : \tau_1 \vee
\tau_2).~\psi$ is just syntactic sugar for $\small \forall a. (\oper{a}{\tau_1}
\vee \oper{a}{\tau_2}) \Rightarrow \psi$.

Quantifier-free propositions in our contract language are conjunctions,
disjunctions and implications of predicates expressing relations between pairs
of effect variables. The syntactic class of relations is seeded with primitive
$\visZ$, $\soZ$, and $\sameobjZ$ relations, and also admits derived relations
that are expressible as union, intersection, or transitive
closure\footnote{Strictly speaking, $R^{+}$ is not the transitive closure of
$R$, as transitive closure is not expressible in FOL.  Instead, $R^{+}$ in our
language denotes \emph{a} superset of transitive closure of $R$. Formally,
$R^{+}$ is any relation $R'$ such that forall $x$, $y$, and $z$, a) $R(x,y)
\Rightarrow R'(x,y)$, and b) $R'(x,y) \conj R'(y,z) \Rightarrow R'(x,z)$} of
primitive relations.  Commonly used derived relations are the \emph{same object
session order} ($\small \sooZ = \soZ ~\cap~ \sameobjZ$), and the \emph{same
object happens-before order} ($\small \hboZ = (\sooZ ~\cup~ \visZ)^+$).

\subsection{Semantics}

\begin{figure}
\begin{smathpar}
\begin{array}{lclcl}
\multicolumn{5}{l}{
  {\eff} \in \mathtt{Effect} \qquad
  {\cv} \in \mathtt{Contract} \qquad
  \set{\eff} \in \mathtt{Effect\; Set}
}\\
\EffSoup & \in & \mathtt{EffSoup}	  & \coloneqq & \set{\eff} \\
\visZ, \soZ, \sameobjZ &	\in & \mathtt{Relations} & \coloneqq & \EffSoup \times \EffSoup \\
%\sameobjZ		&     &  & \\
{\E} 		& \in & \mathtt{ExecState}  & \coloneqq & \Exec \\
\end{array}
\end{smathpar}

\caption{Axiomatic execution.}
\label{sem:contracts}
\end{figure}

\name contracts are constraints over axiomatic definitions of program
executions. Figure~\ref{sem:contracts} summarizes artifacts relevant to define
an axiomatic execution. We formalize an axiomatic execution as a tuple $\Exec$,
where $\EffSoup$, called the \emph{effect soup}, is the set of all effects
generated during the program execution, and $\visZ,\soZ,\sameobjZ \subseteq
\EffSoup \times \EffSoup$ are \emph{visibility}, \emph{session order}, and
\emph{same object} relations, respectively, witnessed over generated effects at
run-time.

Note that the axiomatic definition of an execution ($\E$) provides
interpretations for primitive relations (eg: $\visZ$) that occur free in
contract formulas, and also fixes the domain of quantification to set of all
effects ($\EffSoup$) observed during the program execution. As such, $\E$ is a
potential model for any first-order formula ($\cv$) expressible in our contract
language. If $\E$ is indeed a valid model for $\cv$ (expressed using the
model-theoretic consequence relation as $\E \models \cv$), we say that the
execution $\E$ satisfied the contract $\cv$:
\begin{definition}
An axiomatic execution $\E$ is said to satisfy a contract $\cv$ if and
only if $E \models \cv$.
\end{definition}

\subsection{Capturing Store Semantics}
\label{sec:store_sem}

An important aspect of our contract language is its ability to capture
store-level consistency guarantees, along with application-level consistency
requirements. Similar to~\cite{Burckhardt2014}, we can rigorously define a wide
variety of store semantics including those that combine any subset of session
and causality guarantees, and multiple consistency levels.  However, for our
purposes, we identify three particular consistency levels -- eventual, causal,
and strong, commonly offered by many distributed stores with tunable
consistency, with increasing overhead in terms of latency and availability.

\begin{itemize}
\setlength{\itemsep}{2pt}

\item \textbf{Eventually consistency}: Eventually consistent operations can
	be satisfied as long as the client can reach at least one replica. In the
	bank account example, \cf{deposit} is an eventually consistent operation.
	While eventually consistent data stores typically offer \emph{basic} eventual
	consistency with all possible anomalies, we assume that our store provides
	stronger semantics that remain highly-available~\cite{BailisHAT,COPS}; the
	store always exposes a \emph{causal cut} of the updates. This semantics can
	be formally captured in terms of the following contract definition:

  \vspace{-1.5em}
  \begin{smathpar}
  \ecc = \forall a,b. ~\hbo{a}{b} \wedge \vis{b}{\cureff} \Rightarrow \vis{a}{\cureff}
  \end{smathpar}

\item \textbf{Causal consistency}: Causally consistent operations are required
	to see a causally consistent snapshot of the object state, including the
	actions performed on the same session.  The latter requirement implies that
	if two operations $o_1$ and $o_2$ from the same session are applied to two
	different replicas $r_1$ and $r_2$, the second operation cannot be discharged
	until the effect of $o_1$ is included in $r_2$. The \cf{getBalance} operation
	requires causal consistency, as it requires the operations from the same
	session to be visible, which cannot be guaranteed under eventual consistency.
	The corresponding store semantics is captured by the contract $\ccc$ defined
	below:

  \vspace{-1.5em}
  \begin{smathpar}
  \ccc = \forall a.~\hbo{a}{\cureff} \Rightarrow \vis{a}{\cureff}
  \end{smathpar}

\item \textbf{Strong Consistency}: Strongly consistent operations may block
  indefinitely under network partitions. An example is the total-order
  contract on \cf{withdraw} operation. The corresponding store semantics is
	captured by the $\scc$ contract definition:

  \vspace{-1.5em}
  \begin{smathpar}
  \scc = \forall a.~\sameobj{a}{\cureff} \Rightarrow \vis{a}{\cureff} ~\vee~ \vis{\cureff}{a} ~\vee~ a = \cureff
  \end{smathpar}

\end{itemize}

% Contract classification rules
% ------------------------------
\input{contract-classification}

\subsection{Contract Comparison and Classification}

Our goal is to map application-level consistency constraints on operations to
appropriate store-level consistency guarantees capable of satisfying these
constraints.  The ability to express both these kinds of constraints as
contracts in our contract language lets us compare and determine if contract
($\cv_{op}$) of an operation ($\mathit{op}$) is weak enough to be satisfied
under a store consistency level identified by the contract $\cv_{st}$. Towards
this end, we define a binary \emph{weaker than} relation for our contract
language as following:
\begin{definition}
A contract $\cv_{op}$ is said to be weaker than $\cv_{st}$ (written $\cv_{op}
\le \cv_{st}$ ) if and only if $\Delta \vdash \cv_{st} \Rightarrow \cv_{op}$.
\begin{center}
\end{center}
\end{definition}
\vspace{-2em}
\noindent The $\Delta$ referred in the above defintion is a conjunction of
assumptions about the nature of primitive relations, e.g., $\Rvis$ and $\Rso$
are irreflexive, and the happens-before relation $\hbZ$ is acyclic. A
\emph{well-formed} axiomatic execution ($\E$) is expected to satisfy these
assumptions (i.e., $\E \models \Delta$).

If the contract ($\cv_{op}$) of an operation ($\mathit{op}$) is \emph{weaker
than} a store contract ($\cv_{st}$), then constraints expressed by the former
are implied by guarantees provided by the latter. The completeness of
first-order logic allows us to assert that any well-formed execution ($\E$)
that satisfies $\cv_{st}$ (i.e., $\E\models \cv_{st}$) also satisfies
$\cv_{op}$ (i.e., $\E \models \cv_{op}$). Consequently, it is safe to execute
operation $\mathit{op}$ under a store consistency level captured by $\cv_{st}$.

Observe that the contracts $\scc$, $\ccc$ and $\ecc$ are themselves totally
ordered with respect to the $\le$ relation: $\ecc \le \ccc \le \scc$.  This
concurs with the intuition that any contract satisfiable under $\ecc$ or $\ccc$
is satisfiable under $\scc$, and any contract that is satisfiable under $\ecc$
is satisfiable under $\ccc$. We are interested in the \emph{weakest} guarantee
(among $\ecc$, $\ccc$, and $\scc$) required to satisfy the contract. We define
the corresponding consistency level as the \emph{consistency class} of the
contract.

The classification scheme, presented formally in Figure~\ref{sem:classify},
defines rules to judge the consistency class of a contact. For example, the
scheme classifies the \cf{getBalance} contract ($\cv_{gb}$) from
\S~\ref{sec:motivation} as a {\sf\small CausallyConsistent} contract, because
the sequent $\Delta \vdash \ccc \Rightarrow \cv_{gb}$ is valid in first-order
logic (therefore, $\cv_{gb} \le \ccc$), whereas the sequent $\Delta \vdash \ecc
\Rightarrow \cv_{gb}$ is invalid (therefore, $\cv_{gb} \not\le \ecc$). Since we
confine of our contract language to a decidable subset of the logic, validity
of such sequents can be decided mechanically allowing us to automate the
classification scheme in \name.

Along with three straightforward rules that classify contracts into consistency
classes, the classification scheme also presents a rule that judges
well-formedness of a contract. A contract is well-formed if and only if it is
satisfiable under $\scc$ - the strongest possible consistency guarantee that
the store can provide. Otherwise, it is considered ill-formed, and rejected
statically.

\subsection{Soundness of Contract Classification}

We now present a meta-theoretic result that certifies the soundness of
classification-based contract enforcement. To help us state the result, we
define an axiomatic model of the our system described informally in
\S~\ref{sec:sysmod}:

\vspace{-1em}
\begin{smathpar}
\begin{array}{lclcl}
{\it op} 	& \in & \mathtt{Operation} \\
{\tau}		& \in & \mathtt{Consistency Class} 	& \coloneqq & {\sf ec},{\sf cc},{\sf sc} \\
{\sigma} 	& \in & \mathtt{Session} 					 	& \coloneqq & \cdot \ALT \langle op,\tau \rangle; \sigma \\
\Sigma 		& \in & \mathtt{Session\;Soup}   	 	& \coloneqq & \sigma \pll \Sigma \ALT \emptyset \\
					&			&	\mathtt{Config}		  			 	& \coloneqq & \E,\Sigma \\
\end{array}
\end{smathpar}

We model the system as a tuple $\E,\Sigma$, where the axiomatic execution $\E$
captures the data store's current state, and session soup $\Sigma$ is the set
of concurrent client sessions interacting with the store. A session $\sigma$ is
a sequence of pairs composed of replicated data type operations $\mathit{op}$,
tagged with the consistency class $\tau$ of their contracts (as determined by
the contract classification scheme). We assume a rewrite relation of form:

\vspace{-1.7em}
\begin{smathpar}
  \auxred{} {\E,\langle op,\tau \rangle;\sigma \pll \Sigma} {\eff}
    {\E',\sigma \pll \Sigma}
\end{smathpar}

\noindent on the system state. The relation captures the progress of the
execution (from $\E$ to $\E'$)  due to the successful completion of a client
operation $\mathit{op}$ from one of the sessions in $\Sigma$, generating a new
effect $\eff$. If the resultant execution $\E'$ satisfies the store contract
$\cv_\tau$ (i.e., $\E \models \cv_\tau$), then we say that the store has
\emph{enforced} the contract $\cv_\tau$ in the execution $\E'$. With help of
the axiomatic model, we now state the soundness of contract enforcement as
follows:

\begin{theorem}[Soundness of Contract Enforcement]
\label{thm:classification-sound}
Let $\cv$ be a well-formed contract of a replicated data type operation
$\mathit{op}$, and let $\tau$ denote the consistency class of $\cv$ as
determined by the contract classification scheme. For all well-formed execution
states $\E$, $\E'$ such that
$\auxred{} {\E,\langle op,\tau \rangle;\sigma \pll \Sigma} {\eff} {\E', \sigma
\pll \Sigma}$, if $\E' \models \cv_\tau[\eff/\cureff]$, then $\E' \models
\cv[\eff/\cureff]$
\end{theorem}

\noindent The theorem states that if a data store correctly enforces $\scc$,
$\ccc$, and $\ecc$ contracts in all well-formed executions, then the same
store, extended with the classification scheme shown in
Figure~\ref{sem:classify}, can enforce all well-formed \name contracts. The
proof of the theorem is given in the supplementary material\footnote{The
supplementary material also defines an operational semantics that concretizes
the rewrite relation ($\xrightarrow{}$), along with the proof that it correctly
enforces all \name contracts.}.
