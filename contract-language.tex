\section{Contract Language}
\label{sec:contract-lang}

% Contract Language Syntax
% ------------------------
\input{contract-syntax.tex}

In this section, we formalize \name's contract language, and describe our
contract classification scheme, which analyzes a contract and maps it to the
weakest store consistency level sufficient to satisfy its consistency
requirements.

% classifies contracts on the basis of the weakest
% store-level consistency guarantee

\subsection{Syntax}

The syntax of our core contract language is shown in Fig.
~\ref{fig:contract-lang}. The language is based on first-order logic (FOL), and
admits prenex universal quantification over typed effect variables. We use a
special effect variable ($\cureff$) to denote the effect of \emph{current
operation} - the operation for which a contract is being written. The type of
an effect is simply the name of the operation (eg: \cf{withdraw}) that induced
the effect. We admit disjuntion in types to let an effect variable range over
multiple operation names. The contract $\small \forall (a : \tau_1 \vee
\tau_2).~\psi$ is just syntactic sugar for $\small \forall a. (\oper{a}{\tau_1}
\vee \oper{a}{\tau_2}) \Rightarrow \psi$.

Quantifier-free propositions in our contract language are conjunctions,
disjunctions and implications of predicates expressing relations between pairs
of effect variables. The syntactic class of relations is seeded with primitive
$\visZ$, $\soZ$, and $\sameobjZ$ relations, and also admits derived relations
that are expressible as union, intersection, or transitive
closure\footnote{Strictly speaking, $R^{+}$ is not the transitive closure of
$R$, as transitive closure is not expressible in FOL.  Instead, $R^{+}$ in our
language denotes \emph{a} superset of transitive closure of $R$. Formally,
$R^{+}$ is any relation $R'$ such that forall $x$, $y$, and $z$, a) $R(x,y)
\Rightarrow R'(x,y)$, and b) $R'(x,y) \conj R'(y,z) \Rightarrow R'(x,z)$} of
primitive relations.  Commonly used derived relations are the \emph{same object
session order} ($\small \sooZ = \soZ ~\cap~ \sameobjZ$), and the \emph{same
object happens-before order} ($\small \hboZ = (\sooZ ~\cup~ \visZ)^+$).

\subsection{Semantics}

\begin{figure}
\begin{smathpar}
\begin{array}{lclcl}
\multicolumn{5}{l}{
  {\eff} \in \mathtt{Effect} \qquad
  {\cv} \in \mathtt{Contract} \qquad
  \set{\eff} \in \mathtt{Effect\; Set}
}\\
\EffSoup & \in & \mathtt{EffSoup}	  & \coloneqq & \set{\eff} \\
\visZ, \soZ, &	\in & \mathtt{Relations} & \coloneqq &
  \set{\eff}\times\set{\eff} \\
\sameobjZ		&     &  & \\
{\E} 		& \in & \mathtt{ExecState}  & \coloneqq & \Exec \\
\end{array}
\end{smathpar}

\caption{An Axiomatic Execution}
\label{sem:contracts}
\end{figure}

\name contracts are constraints over axiomatic definitions of program
executions.Fig.~\ref{sem:contracts} summarizes artifacts relevant to
define an axiomatic execution. We formalize an axiomatic execution as
a tuple $\Exec$, where $\EffSoup$, called the \emph{effect soup}, is
the set of all effects generated during the program execution, and
$\visZ,\soZ,\sameobjZ \subseteq \EffSoup \times \EffSoup$ are
\emph{visibility}, \emph{session order}, and \emph{same object}
relations, respectively, witnessed over generated effects at run-time.

Note that the axiomatic definition of an execution ($\E$) provides
interpretations for primitive relations (eg: $\visZ$) that occur free
in contract formulas, and also fixes the domain of quantification to
set of all effects ($\EffSoup$) observed during the program execution.
As such, $\E$ is a potential model for any first-order formula ($\cv$)
expressible in our contract language. If $\E$ is indeed a valid model
for $\cv$ (expressed using the model-theoretic consequence relation as $\E
\models \cv$), we say that the execution $\E$ satisfied the contract
$\cv$:
\begin{definition}
An axiomatic execution $\E$ is said to satisfy a contract $\cv$ if and
only if $E \models \cv$.
\end{definition}

\subsection{Capturing Store Semantics}

An important aspect of our contract language is its ability to capture
store-level consistency guarantees, along with application-level
consistency requirements. Similar to~\cite{Burckhardt2014}, we can
rigorously define a wide variety of store semantics including those
that combine any subset of session and causality guarantees, and
multiple consistency levels.  However, for our purposes, we identify
three particular consistency levels -- eventual, causal, and strong,
commonly offered by many distributed stores with tunable consistency,
with increasing overhead in terms of latency and availability. For
each of the these three consistency levels, we capture the semantics
as a formula in our contract language, and informally describe the kind
of application-level consistency requirements that can met under the
consistency level:

% Indeed, the techniques presented here can be
% extended to other consistency stratifications. We assign each
% application-level contract into one of these following classes:

\begin{itemize}
\setlength{\itemsep}{2pt}

\item \textbf{Eventually consistency}: Eventually consistent operations can
  be satisfied as long as the client can reach at least one replica. For
  example, \cf{deposit} is an eventually consistent operation; its semantics
  does not require its action to manifest on all replicas before other
  operations in its session are allowed to proceed. While eventually
  consistent data stores typically offer \emph{basic} eventual consistency
  with all possible anomalies, we assume that our store provides stronger
  semantics that remain highly-available~\cite{BailisHAT,COPS}; the store
  always exposes a causal cut of the updates. This semantics can be formally
  captured in terms of the following contract definition:

  \vspace{-1em}
  \begin{smathpar}
  \ecc = \forall a,b. ~\hbo{a}{b} \wedge \vis{b}{\cureff} \Rightarrow \vis{a}{\cureff}
  \end{smathpar}
  \noindent where $\small \hboZ = ((\soZ \cap \sameobjZ) \cup \visZ)^+$.

\item \textbf{Causal consistency}: Causally consistent operations are required
	to see a causally consistent snapshot of the object state, including the
	actions performed on the same session.  The latter requirement entails that
	if two operations $o_1$ and $o_2$ from the same session are applied to two
	different replicas $r_1$ and $r_2$, the second operation cannot be discharged
	until the effect of $o_1$ is merged with $o_2$ in both $r_1$ and $r_2$. The
	\cf{getBalance} operation requires causal consistency, as it requires the
	operations from the same session to be visible, which cannot be guaranteed
	under just eventual consistency. We assume that causality is only tracked
	through operations on the same object. The corresponding store semantics is
	captured by the contract $\ccc$ defined below:

  \vspace{-1em}
  \begin{smathpar}
  \ccc = \forall a.~(\hboZ \cap \sameobjZ) (a,\cureff) \Rightarrow \vis{a}{\cureff}
  \end{smathpar}

  %%; two operations in the same session but on different objects are
  %% considered causally unrelated under this definition. Stores typically
  %%avoid tracking causality across objects to mitigate overheads when
  %% causality tracking is unnecessary.

\item \textbf{Strong Consistency}: Strongly consistent operations may block
  indefinitely under network partitions. An example is the total-order
  contract on \cf{withdraw} operation. The corresponding store semantics is
  captured by the $\scc$ contract definition:

  \vspace{-1em}
  \begin{smathpar}
  \scc = \forall a.~\sameobj{a}{\cureff} \Rightarrow \vis{a}{\cureff} ~\vee~ \vis{\cureff}{a} ~\vee~ a = \cureff
  \end{smathpar}

\end{itemize}

% SJ: not sure this is necessary, or appropriate here.
%% \noindent Observe that out contract language does not incorporate real (i.e.,
%% wall-clock) time. Hence, it cannot describe store
%% semantics such as recency or bounded-staleness
%% guarantees offered by certain stores~\cite{Pileus}.


% Contract classification rules
% ------------------------------
\input{contract-classification}

\subsection{Contract Comparison and Classification}

Our goal is to map application-level consistency constraints on
operations to appropriate store-level consistency guarantees capable
of satisfying these constraints.  The ability to express both of them as
contracts in our contract language lets us compare and determine if
contract ($\cv_{op}$) of an operation ($\mathit{op}$) is weak enough to be
satisfied under a store consistency level identified by the contract
$\cv_{st}$. Towards this end, we define a binary \emph{weaker than}
relation for our contract language as following:

\begin{definition}
A contract $\cv_{op}$ is said to be weaker than $\cv_{st}$ (written $\cv_{op}
\le \cv_{st}$ ) if and only if $\Delta \vdash \cv_{st} \Rightarrow \cv_{op}$.
\begin{center}
\end{center}
\end{definition}

\vspace{-1em}
\noindent The $\Delta$ referred in the above defintion is a
conjunction of assumptions about the nature of primitive relations,
such as $\Rvis$ and $\Rso$ are irreflexive, and the happens-before
relation $\hbZ$ is acyclic. A \emph{well-formed} axiomatic execution
($\E$) is expected to satisfy these assumptions (i.e., $\E \models
\Delta$).

If the contract ($\cv_{op}$) of an operation ($\mathit{op}$) is \emph{weaker
than} a store contract ($\cv_{st}$), then constraints expressed by the
former are implied by guarantees provided by the later. Due to the
completeness of first-order logic\cite{completeness}, this means that
any well-formed execution ($\E$) that satisfies $\cv_{st}$ (i.e.,
$\E\models \cv_{st}$) also satisfies $\cv_{op}$ (i.e., $\E \models
\cv_{op}$). Consequently, it is safe to execute operation $\mathit{op}$ under
store consistency level captured by $\cv_{st}$.

Observe that the contracts $\scc$, $\ccc$ and $\ecc$ are themselves
totally ordered with respect to the $\le$ relation: $\ecc \le \ccc \le
\scc$.  This concurs with the intuition that any contract satisfiable
under $\ecc$ or $\ccc$ is satisfiable under $\scc$, and any contract
that is satisfiable under $\ecc$ is satisfiable under $\ccc$. However,
we are interested in the \emph{weakest} guarantee (among $\ecc$,
$\ccc$, and $\scc$) required to satisfy the contract. We define the
corresponding consistency level as the \emph{consistency class of the
contract}. The classification scheme, presented formally in
Figure~\ref{sem:classify}, defines rules to judge consistency class of
a contact. For example, the scheme classifies \cf{getBalance} contract
($\cv_{gb}$) from Sec.~\ref{sec:motivation} as a {\sf
CausallyConsistent} contract, because the sequent $\Delta \vdash \ccc
\Rightarrow \cv_{gb}$ is valid in first-order logic (therefore,
$\cv_{gb} \le \ccc$), whereas the sequent $\Delta \vdash \ecc
\Rightarrow \cv_{gb}$ is invalid (therefore, $\cv_{gb} \not\le \ecc$).
Due to the confinement of our contract language to a decidable subset
of the logic, validity of such sequents can be decided mechanically
allowing us to automate the classification scheme in \name.

Along with three straightforward rules that classify contracts into
consistency classes, the classification scheme also presents a rule
that judges well-formedness of a contract. A contract is well-formed
if and only if it is satisfiable under $\scc$ - the strongest possible
consistency guarantee any store can provide. Otherwise, it is
considered ill-formed, and rejected statically.

\subsection{Soundness of Contract Classification}

In this section, we present a meta-theoretic result that certifies the
soundness of classification-based contract enforcement. To help us
state the result, we present an axiomatic model of the our system
described informally in Sec.~\ref{sec:sysmod}:

\begin{smathpar}
\begin{array}{lclcl}
\multicolumn{5}{l}{
  {op} \in \mathtt{Operation} \qquad
  \tau \in \mathtt{Consistency\; Class}
}\\
\cv(\tau) & \in & \mathtt{Store\; Contract\; of \; \tau} & \coloneqq & \scc,
  \ccc, \ecc\\
{\sigma} & \in & \mathtt{Session} & \coloneqq & \cdot \ALT (op,\tau); \sigma \\
\Sigma 	& \in & \mathtt{Session\;Soup}   & \coloneqq &
  \langle s,{\sigma} \rangle \pll \Sigma \ALT \emptyset \\
				&			&	\mathtt{Store}		  & \coloneqq & \E;\Sigma \\
\end{array}
\end{smathpar}

We model the system as a tuple $\E;\Sigma$, where the execution $\E$
captures the data store's current state of the execution, and
$\Sigma$, the session soup, is the set of concurrent client sessions
interacting with the store. A session is modeled simply as a sequence
of replicated data type operations ($\mathit{op}$), tagged with the consistency
class ($\tau$) of their contracts (as determined by the contract
classification scheme). We assume a rewrite relation of form:

\vspace{-1.7em}
\begin{smathpar}
  \auxred{} {\E;\langle (op,\tau);\sigma \rangle \pll \Sigma} {\eff}
    {\E';\langle \sigma \rangle \pll \Sigma'}
\end{smathpar}

\noindent on the system state. The relation captures the progress of
the execution (from $\E$ to $\E'$)  due to the successful completion
of a client operation ($\mathit{op}$) from one of the sessions in $\Sigma$,
generating a new effect ($\eff$). If the resultant execution ($\E'$)
satisfies the store contract ($\cv(\tau)$) of $\tau$ (i.e., $\E
\models \cv(\tau)$), then we say that the store has \emph{enforced} the
contract $\cv(\tau)$ in the execution $\E'$.

With help of the axiomatic model, we now state the soundness of
contract enforcement as follows:

\begin{theorem}[Soundness of Contract Enforcement]
\label{lem:core-preservation}
Let $\cv$ be a well-formed contract of a replicated data type operation $\mathit{op}$,
and let $\tau$ denote the consistency class of $\cv$ as determined by
the contract classification scheme. Forall well-formed execution
states $\E$, $\E'$ such that
$\auxred{} {\E;\langle (op,\tau);\,\sigma \rangle \pll \Sigma} {\eff}
 {\E';\langle \sigma \rangle \pll \Sigma}$
if $\E' \models [\eff/\cureff]\,\cv(\tau)$, then $\E' \models [\eff/\cureff]\,\cv$
\end{theorem}

The theorem states that if a data store correctly enforces $\scc$, $\ccc$,
and $\ecc$ contracts in all well-formed executions, then the same store,
extended with classification scheme, can enforce all well-formed \name
contracts. The proof of the theorem has been relegated to our tech report
and is provided as part of the supplementary
material~\cite{techrep}\footnote{The supplementary material and tech report
  also defines an operational semantics that concretizes the rewrite
  relation ($\xrightarrow{}$), along with the proof that it correctly
  enforces all \name contracts.}.


