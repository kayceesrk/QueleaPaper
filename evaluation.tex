\section{Evaluation}

In this section, we evaluate \name programs and report their contract profile
as well as illustrating the performance benefits of fine-grained consistency
classification on operations and transactions. We also report on the impact of
the summarization. We implemented the following applications, which includes
RDTs as well as larger applications composed of severals RDTs:

\begin{itemize}
\item \textbf{LWW register}: A last-write-wins register.
\item \textbf{DynamoDB register}: A integer register that allows eventual and
strong puts and gets, conditional puts, increment and decrement operations.
\item \textbf{Bank account}: Our running example, with savings and current
accounts. \item \textbf{Shopping list}: Collaborative shopping list which
allows adding and deleting items. \item \textbf{Online store}: Models an online
store with shopping cart and dynamically changing item prices. Checkout process
verifies that the custormer only pays the accepted price. \item \textbf{RuBis}:
An ebay-like auction site~\cite{}. \item \textbf{Microblog}: A twitter-like
microblogging site, modelled after Twissandra~\cite{}. \end{itemize}

\subsection{Contract Characteristics}

\begin{table} \setlength{\tabcolsep}{4pt} {\sffamily \small \begin{center}
\begin{tabular} {|l|r|r|r|r|r|r|r|r|} \hline {\bf Benchmark} & {\bf LOC} & {\bf
\#T} & {\bf EC} & {\bf CC} & {\bf SC} & {\bf RC} & {\bf MAV} & {\bf RR} \\
\hline {LWW Reg} & 108 & 1 & 2 & 2 & 2 & 0 & 0 & 0 \\ {DynamoDB} & 126 & 1 & 3
& 1 & 2 & 0 & 0 & 0 \\ {Bank Account} & 155 & 1 & 1 & 1 & 1 & 1 & 0 & 1 \\
{Shopping List} & 140 & 1 & 2 & 1 & 1 & 0 & 0 & 0 \\ {Online store} & 340 & 4 &
9 & 1 & 0 & 2 & 0 & 1 \\ {Rubis} & 640 & 6 & 14 & 2 & 1 & 4 & 2 & 0 \\
{Microblog} & 659 & 5 & 13 & 6 & 1 & 6 & 3 & 1 \\ \hline \end{tabular}
\end{center} } \caption{The distribution of classfied contracts. \#T refers to
the number of tables in the application. The columns 4-6 (7-9) represent
operations (transactions) assigned to this consistency (isolation) level.}
\label{tab:ctrts} \end{table}

The distribution of contracts in these applications is given in
Table~\ref{tab:ctrts}. We see that majority of the operations are classified as
eventually consistent. Typically, causally consistent operations tend to be
reads that require to see operations in the same session or causally preceding
effects. Transactions are useful for maintaining cross-object consistency and
integrity constraints. For example, we maintain foregin key relationship
between tables using RC isolation level on the insertion transaction, and MAV
on the read transaction; if a MAV transaction witnesses the foreign key field
on table, then it \emph{will} witness the corresponding primiary key row in the
referenced table.

RR transaction comes in handy for maintaining the integrity of follow user
functionality in microblog. If user $A$ is followed by $B$, then we add a
\emph{followedBy} edge from $A$ to $B$ and a \emph{following} edge in the other
direction. The integrity constraint is that either both the edges are added, or
none. RR transaction isolation level is used to ensure correctness when
concurrently $A$ blocks $B$, and $B$ follows $A$. By operating on a snapshot of
consistent state, the block user transaction will not be interfered by the
concurrent follow user transaction.

The proof obligations associated with contract classfication is discarged
through the Z3 SMT Solver. In particular, the contract classification process
is completely performed compile time and has no overheads at runtime. Across
our benchmarks, classifying a contract took 11.5 milliseconds on average.

\subsection{Performance}

In this section, we study the performance benefit of fine-grained contract
classification, and the impact of summarization optimization.

\subsection{Configuration}

We deploy \name applications in \emph{clusters} where each cluster is composed
of 5 fully replicated Cassandra replicas within the same datacenter. We
instantiate one shim layer node for every cassandra replica, an place it on the
same VM as the cassandra replica. The clients are instantiated on the same data
center as the store.
