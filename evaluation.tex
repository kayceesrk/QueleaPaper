\section{Evaluation}

In this section, we evaluate \name programs and report their contract profile
as well as illustrating the performance benefits of fine-grained consistency
classification on operations and transactions. We also report on the impact of
the summarization. We implemented the following applications, which includes
RDTs as well as larger applications composed of severals RDTs:

\begin{itemize} \item \textbf{LWW register}: A last-write-wins register. \item
\textbf{DynamoDB register}: A integer register that allows eventual and strong
puts and gets, conditional puts, increment and decrement operations. \item
\textbf{Bank account}: Our running example, with savings and current accounts.
\item \textbf{Shopping list}: Collaborative shopping list which allows adding
and deleting items. \item \textbf{Online store}: Models an online store with
shopping cart and dynamically changing item prices. Checkout process verifies
that the custormer only pays the accepted price. \item \textbf{RuBis}: An
ebay-like auction site~\cite{}. \item \textbf{Microblog}: A twitter-like
microblogging site, modelled after Twissandra~\cite{}. \end{itemize}

\subsection{Contract Characteristics}

\begin{table} \setlength{\tabcolsep}{4pt} {\sffamily \small \begin{center}
\begin{tabular} {|l|r|r|r|r|r|r|r|r|} \hline {\bf Benchmark} & {\bf LOC} & {\bf
\#T} & {\bf EC} & {\bf CC} & {\bf SC} & {\bf RC} & {\bf MAV} & {\bf RR} \\
\hline {LWW Reg} & 108 & 1 & 2 & 2 & 2 & 0 & 0 & 0 \\ {DynamoDB} & 126 & 1 & 3
& 1 & 2 & 0 & 0 & 0 \\ {Bank Account} & 155 & 1 & 1 & 1 & 1 & 1 & 0 & 1 \\
{Shopping List} & 140 & 1 & 2 & 1 & 1 & 0 & 0 & 0 \\ {Online store} & 340 & 4 &
9 & 1 & 0 & 2 & 0 & 1 \\ {Rubis} & 640 & 6 & 14 & 2 & 1 & 4 & 2 & 0 \\
{Microblog} & 659 & 5 & 13 & 6 & 1 & 6 & 3 & 1 \\ \hline \end{tabular}
\end{center} } \caption{The distribution of classfied contracts. \#T refers to
the number of tables in the application. The columns 4-6 (7-9) represent
operations (transactions) assigned to this consistency (isolation) level.}
\label{tab:ctrts} \end{table}

The distribution of contracts in these applications is given in
Table~\ref{tab:ctrts}. We see that majority of the operations are classified as
eventually consistent. Typically, causally consistent operations tend to be
reads that require to see operations in the same session or causally preceding
effects. Transactions are useful for maintaining cross-object consistency and
integrity constraints. For example, we maintain foregin key relationship
between tables using RC isolation level on the insertion transaction, and MAV
on the read transaction; if a MAV transaction witnesses the foreign key field
on table, then it \emph{will} witness the corresponding primiary key row in the
referenced table.

RR transaction comes in handy for maintaining the integrity of follow user
functionality in microblog. If user $A$ is followed by $B$, then we add a
\emph{followedBy} edge from $A$ to $B$ and a \emph{following} edge in the other
direction. The integrity constraint is that either both the edges are added, or
none. RR transaction isolation level is used to ensure correctness when
concurrently $A$ blocks $B$, and $B$ follows $A$. By operating on a snapshot of
consistent state, the block user transaction will not be interfered by the
concurrent follow user transaction.

The proof obligations associated with contract classfication is discarged
through the Z3 SMT Solver. In particular, the contract classification process
is completely performed compile time and has no overheads at runtime. Across
our benchmarks, classifying a contract took 11.5 milliseconds on average.

\subsection{Performance}

In this section, we study the performance benefit of fine-grained contract
classification, and the impact of summarization optimization.

\subsection{Configuration}

We deploy \name applications in \emph{clusters} where each cluster is composed
of 5 fully replicated Cassandra replicas within the same datacenter. We
instantiate one shim layer node for every cassandra replica, an place it on the
same VM as the cassandra replica. The clients are instantiated on the same data
center as the store, and run the transactions. We deploy the each node in the
cluster cluster on \cf{c3.4xlarge} Amazon EC2 instances with 16 virtual CPUs,
30GB memory, and 320GB of SSD storage. Our shim layer nodes are multi-threaded,
and we allocate 8 CPUs for each shim layer node. The clients also run on
\cf{c2.4xlarge} instances. We call this deployment \cf{1DC}. For our WAN
experiments, we instantiate 2 clusters (each with 5 nodes), one in US-east (N.
Virginia) and another in US-west (Oregon). The average latency between the
regions was 85 ms. We call this deployment \cf{2DC}.

\subsection{LWW Register}

\begin{figure*}
  \centering
  \subfigure[Perf. Oper. 1DC]{\label{grf:LWW-perf-1DC}\includegraphics[width=0.24\textwidth]{graphs/LWW-tp-vs-lat-1DC.pdf}}
  \subfigure[Perf. Oper. 2DC]{\label{grf:LWW-perf-2DC}\includegraphics[width=0.24\textwidth]{graphs/LWW-tp-vs-lat-2DC.pdf}}
  \subfigure[Perf. Txn. 1DC]{\label{grf:LWW-txn-1DC}\includegraphics[width=0.24\textwidth]{graphs/LWW-tp-vs-lat-1DC-txn.pdf}}
  \subfigure[Mutation Prof. 1DC]{\label{grf:LWW-txn-wp}\includegraphics[width=0.24\textwidth]{graphs/LWW-txn-wp-vs-tp.pdf}}
	\caption{Performance of LWW Register RDT.}
  \label{grf:LWW_perf}
\end{figure*}

We analyze the performance of different consistency classifications in \name
using the LWW register. Our client workload was generated using YCSB
benchmark~\cite{}, with the default workload of 50\% reads and 50\% writes,
with keys uniformly chosen from a set of 1000 keys. We varied the number of
clients from 128 to 1024, with each workload running for 180 seconds.
Last-writer-wins is the conflict resolution policy used by Cassandra. Hence, we
are able to directly compare the performance of \name implementation against
Cassandra.

Figure~\ref{grf:LWW-perf-1DC} shows the throughput vs. latency graph for the
different consistency levels. We also include Cassandra, which provides basic
eventual consistency. Recall that \name's eventual consistency is stronger than
the guarantees provided by Cassandra (Section~\ref{sec:store_sem}). With 512
clients, the average latency of operations on Cassandra was 32.24 milliseconds.
EC and CC under \name was 30\% and 57\% slower whereas strong consistency was
241\% slower. EC(SC) was able to achieve 80\%(40\%) of throughput of vanilla
Cassandra. The results show that while \name provides an expressive programming
model with stronger consistency guarantees, its performance is comparable to
vanilla Cassandra. However, SC has a huge performance hit due to coordination
between all the replicas for obtaining object leases as well as reading and
writing to all replicas.
