\section{Motivation}
\label{sec:motivation}

Consider how we might implement a highly available bank account on top of an
eventually consistent data store, with the \emph{integrity} constraint that the
balance should never drop below 0. We will begin by implementing the bank
account replicated data type (RDT) in \name, and then describe the mechanisms
to obtain the desired correctness guarantees.

\subsection{RDT specification}

A key novelty	in \name is that it allows the addition of new RDTs to the store,
immensely improving the programmability of data stores. The programmer no
longer has to coerce the application logic to utilize the store provided data
types. In addition, \name treats the convergence semantics of the data type
separately from the consistency properties. The separation of concern allows
the programmer to \emph{operationally} reason about conflict resolution, while
permitting \emph{declarative} reasoning for consistency. As mentioned in the
previous section, RDTs are described in terms of operations on a RDT object,
where each operation is described as a reduction over the state of the object
i.e., the list of effects. Let us assume that the bank account object provides
three operations: \cf{deposit}, \cf{withdraw} and \cf{getBalance}, with the
assumption that the withdraw fails if the account has insufficient balance.
Every operation in \name is of the following type, written in Haskell syntax:

\begin{codehaskell}
type Operation = (Effect e, Arg a, Res r)
               => [e] -> a -> (r, Maybe e)
\end{codehaskell}

\noindent It takes a list of effects (the \emph{context} for the operation), an
argument and returns a result along with an optional effect. Read-only
operations do not return any effect. If an effect is returned, it is added to
the state of the object at the current replica, and asynchronously sent to
other replicas. The implementation of the bank account operations in \name is
given below:

\begin{codehaskell}
data Acc = Deposit_ Int | Withdraw_ Int | GetBalance_

getBalance :: [Acc] -> () -> (Int, Maybe Acc)
getBalance ctxt _ =
  let res = sum [x | Deposit_ x <- ctxt]
						- sum [x | Withdraw_ x <- ctxt]
	in (res, Nothing)

deposit :: [Acc] -> Int -> ((), Maybe Acc)
deposit _ amt = (amt, Just $ Deposit_ amt)

withdraw :: [Acc] -> Int -> (Bool, Maybe Acc)
withdraw ctxt v =
	if sel1 $ getBalance ctxt () >= v
  then (True, Just $ Withdraw_ v)
	else (False, Nothing)
\end{codehaskell}

The datatype \cf{Acc} represents the effect type for the bank account. The
context of the operations is a snapshot of the state of the object at some
replica. In this sense, every operation on the RDT is atomic, and thus
permitting sequential reasoning for implementing eventually consistent data
types. We have implemented a large corpus of RDTs for realistic benchmarks
including shopping carts, auction and micro-blogging sites in few tens of lines
of code.

\subsection{Anomalies under Eventual Consistency}

Our goal is to choose the correct consistency level for each of the bank
account operations such that (1) the balance never drops below zero and (2) the
\cf{getBalance} operation never incorrectly returns a negative balance. To be
able to do this, we need to consider the anomalies that could arise under
eventual consistency.

\begin{figure}
\centering
\subfigure[Unsafe withdraw]{\label{fig:unsafeWithdrawAnomaly}\includegraphics[width=0.34\columnwidth]{Figures/Motivation4}}
\hfill
\subfigure[Negative balance]{\label{fig:negativeBalanceAnomaly}\includegraphics[width=0.31\columnwidth]{Figures/Motivation2}}
\hfill
\subfigure[Missing update]{\label{fig:missingUpdateAnomaly}\includegraphics[width=0.26\columnwidth]{Figures/Motivation1}}
\caption{Anomalies possible under eventual consistency for the get balance operation.}
\label{fig:cleanliness_examples}
\end{figure}

Consider the execution shown in Figure~\ref{fig:unsafeWithdrawAnomaly}. Assume
that all operations in the figure are on the same bank account object with the
initial balance being zero. Session 1 performs a \cf{deposit} of 100, followed
by a \cf{withdraw} of 80 in the same session. The \cf{withdraw} operation
witnesses the deposit and succeeds\footnote{Although visibility and session
order relations relate effects, we have abused the notation in these examples
to relate operations, with the idea that the relations relate the effect
emitted by those operations}. Subsequently, session 2 perform a \cf{withdraw}
operation, but importantly, due to eventual consistency, only witnesses the
\cf{deposit} from session 1, but not the subsequent withdraw. Hence, this
\cf{withdraw} also \emph{incorrectly} succeeds, violating the integrity
constraint. A subsequent \cf{getBalance} operation, that happens to witness all
the previous operations,  would report a negative balance.

It is easy to see that the only way to ensure the integrity constraint on
\cf{balance} is to prevent concurrent withdrawals on the same bank account
object. This can be done by insisting that \cf{withdraw} be executed with
strong consistency properties. Although this prevents the integrity constraint
from being violated, a strongly consistent \cf{withdraw} itself is not
sufficient to prevent \cf{getBalance} from ever reporting a negative balance to
the end user.

Consider the execution shown in fig.~\ref{fig:negativeBalanceAnomaly}, which
consists of three concurrent sessions performing a \cf{deposit}, a
\cf{withdraw}, and a \cf{getBalance} operation, respectively, on the same bank
account object. As before, assume that the initial balance in the account is
zero. As the \cf{vis} edge indicates, operation \cf{withdraw(50)} in session 2,
can witnesses the effects of \cf{deposit(100)} from session 1, leading it to
rightfully conclude that the current balance is 50. Consequently,
\cf{withdraw(50)} is performed safely. The effect of this \cf{withdraw}
operation subsequently becomes visible to the \cf{getBalance} in Session 3.
However, because \cf{getBalance} only witnesses the effect of the \cf{withdraw}
operation from session 2, but not the \cf{deposit} from session 1, reports the
balance of negative 50 to the user.

Producing a negative balance is not the only inconsistency that the user is
exposed to under an eventually consistent bank account. Figure
~\ref{fig:missingUpdateAnomaly} shows an execution where the \cf{getBalance}
operation in a session does not witness the effects of an earlier \cf{withdraw}
operation performed in the same session, possibly because it was served by a
replica that has not yet merged the \cf{withdraw} effect, served by a different
replica. This anomaly leads the user to incorrectly conclude that the
\cf{withdraw} operation failed to go through.

Although it is easy to understand the reasons behind the occurrence of the
aforementioned negative balance and missing update anomalies, finding the
appropriate fixes is not readily apparent. Making \cf{getBalance} a strongly
consistent operation is definitely sufficient to avert anomalies, but is it
really necessary? Given the cost of enforcing strong
consistency~\cite{DynamoDB, Pileus}, it is preferable to avoid it unless
there are no viable alternatives.  Exploring the space of these alternatives
requires understanding the subtle differences in semantics of various kinds
of weak consistency alternatives.

\subsection{Specifications and Contracts}

\name helps facilitate the mapping of operations to appropriate consistency
levels by letting the programmer declare application-level consistency
constraints as \emph{contracts} that axiomatically specify the set of allowed
executions involving this operation.  In the case of the bank account example,
any execution that does not exhibit the anomalies described in the previous
section is a \emph{well-formed} execution on the bank account object.  By
specifying the set of legal executions for each data type in terms of a trace
of operation invocations on that type, \name\ ensures that all executions over
that type are well-formed.

In our running example, it is clear that in order to preserve the integrity
constraint, the \cf{withdraw} operation must be strongly consistent.  That is,
given two \cf{withdraw} operations $a$ and $b$, either $a$ is visible to $b$ or
vice versa. Utilizing the primitive relations described in
Section~\ref{sec:sysmod}, we express this application-level consistency
requirement as a contract or specification over \cf{withdraw}:

\vspace{-1em}
\begin{smathpar}
\begin{array}{l}
\forall (a : \rcf{withdraw}).~\sameobj{a}{\cureff} \Rightarrow a = \cureff \vee \vis{a}{\cureff} \vee \vis{\cureff}{a}
\end{array}
\end{smathpar}

\noindent Here, $\cureff$ stands for the effect emitted by the \cf{withdraw} operation.
The syntax $a:\rcf{withdraw}$ states that $a$ is an effect which was emitted
by a \cf{withdraw} operation i.e., $\oper{a}{\rcf{withdraw}}$ holds.  The
contract specifies that if the current operation emits an effect $\cureff$,
then for any operation $a$ which was emitted by a \cf{withdraw} operation, it
is the case that $a = \cureff$ or $a$ is visible to $\cureff$, or vice versa.
Any execution on a bank account object that preserves the above contract for a
\cf{withdraw} operation is said to be derived from a correct implementation of
\cf{withdraw}.

\noindent For \cf{getBalance}, we construct the following contract:

\vspace{-1em}
\begin{smathpar}
\begin{array}{l}
\forall (a:\rcf{deposit}), (b:\rcf{withdraw}), (c: \rcf{deposit} \vee \rcf{withdraw}). \\
\qquad \vis{a}{b} \wedge \vis{b}{\cureff} \Rightarrow \vis{a}{\cureff} \\
\qquad \wedge~ (\soZ \cap \sameobjZ) (c,\cureff) \Rightarrow \vis{c}{\cureff}
\end{array}
\end{smathpar}

\noindent The expression $c:\rcf{deposit} \vee \rcf{withdraw}$ states that $c$ is an
effect that was emitted either by a \cf{deposit} or a \cf{withdraw} operation.
If a \cf{withdraw} $b$ is visible to \cf{getBalance}, then all \cf{deposit}
operations $a$ visible to the \cf{withdraw} should also be visible to
\cf{getBalance}. This prevents negative balance anomalies.

Our specification language provides operators to compose
relations. Thus, the syntax $(R_1 \cap R_2)(a,b)$ is equivalent to $R_1(a,b)
\wedge R_2(a,b)$. The last line of the above contract says that if a
\cf{deposit} or a \cf{withdraw} operation precedes a \cf{getBalance} operation in
session order, and is applied on the same object as the \cf{getBalance}
operation, then it must be the case that the \cf{getBalance} operation
witnesses the effects of the preceding operations.

Since there are no restrictions on when and how a \cf{deposit} operation can
execute, its contract is simply $\small \true$.

\subsection{From Contracts to Implementation}

Notice that the contracts for \cf{withdraw} and \cf{getBalance} only express
application-level consistency requirements, and make no reference to the
semantics of the underlying store. To write contracts, a programmer only needs
to reason about the semantics of the application under the \name system model.
The mapping of application-level consistency requirements to appropriate
store-level guarantees is done automatically behind-the-scene.

How might one go about ensuring that any execution adheres to the contract? The
challenge is that a contract provides a declarative (axiomatic) specification
of an execution, while what is required is is an operational procedure for
\emph{enforcing} its implicit constraints. One strategy would be to execute
operations speculatively.  Here, operations are tentatively applied as they are
received from the client or other replicas. We can maintain a runtime
manifestation of executions, and check well-formedness conditions at runtime,
rolling back executions if they are ill-formed. However, the overhead of state
maintenance and the complexity of user-defined contracts make this technique
infeasible in practice.

We devise a static approach instead. Contracts are analyzed with the help of a
theorem prover, and statically mapped to a particular store-level consistency
property that the prover guarantees preserves contract semantics. We call this
procedure \emph{contract classification}. Given the variety and complexity of
store level consistency properties, the idea is that the system implementor
parameterizes the classification procedure by describing the store semantics in
the \emph{same} contract language as the one used to express the contract on
the operations. In the next section, we describe the contract language in
detail and describe the classification procedure for a particular store
semantics.
