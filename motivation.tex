\section{Motivation}
\label{sec:motivation}

In this section, we motivate the need and benefit of declarative reasoning under
eventual consistency with the help of an example. We begin with a description of
our system and programming model, and introduce the primitive relations that
constitute an essential part of our contract language.

\subsection{System Model}
\label{sec:sysmod}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{Figures/SystemModel}
\caption{Quelea system model.}
\label{fig:sysmod}
\end{figure}

Figure~\ref{fig:sysmod} provides a schematic diagram of our system model. The
distributed store is composed of a collection of \emph{replicas}, each of which
stores a set of \emph{objects} ($x,y,\ldots$). We assume that every object is
replicated at every replica in the store. The state of an object at any replica
is the set of all updates (\emph{effects}) performed on the object. For
example, the state of $x$ at replica 1 is the set composed of effects $w^x_1$
and $w^x_2$.

Each object is associated with a set of \emph{operations}. The clients interact
with the store by invoking the operations on objects. The sequence of operations
invoked by a particular client on the store is called a \emph{session}. The
data store is typically accessed by a large number of clients (and hence
sessions) concurrently. Importantly, the clients are oblivious to which replica
an operation is applied to; the data store may choose to route the operation to
the closest replica for minimizing latency, or route it to a different replica
in order to balance the load in the system. For example, the operations $foo$
and $bar$ invoked by the same session on the same object, might end up being
applied to different replicas because replica 1 to which $foo$ was applied to
might be unreachable when invoking $bar$.

Suppose an operation $foo$ is invoked on a object $x$ with arguments $arg_1$ at
replica 1. The operation $foo$ simply \emph{reduces} over the current set of
effects at that replica on that object ($w^x_1$ and $w^x_2$), produces a result
$v1$ that is sent back to the client, and emits a \emph{single} new effect
$w^x_4$, which is appended to the state $x$ at replica 1. Thus, every operation
is evaluated over a \emph{snapshot} of the state of the object on which it is
invoked. In this case, we say that the effect $w^x_4$ \emph{witnessed} $w^x_1$
and $w^x_2$. Alternatively, $w^x_1$ and $w^x_2$ are \emph{visible} to $w^x_4$,
written logically as $\vis{w^x_1}{w^x_4} \wedge \vis{w^x_2}{w^x_4}$, where
$\visZ$ is the visibility relation between the effects. Visibility is an
irreflexive (an operation cannot see its own effect) and asymmetric relation,
and only relates effects produced by operations on the same object.

Read-only operation execution is similar except that they do not produce a new
effect. The effect added to a particular replica is asynchronously sent to
other replicas. We assume that \emph{eventually}, an effect applied at one
replica will be merged into all other replicas. The two effects $w^x_4$ and
$w^x_5$ that arise from the same session are said to be in \emph{session order}
(written logically as $\so{w^x_4}{w^x_5}$). Session order is a irreflexive,
transitive relation. The effects $w^x_4$ and $w^x_5$ arising from operations
applied to the same object $x$ are said to be under the \emph{same object}
relation, written $\sameobj{w^x_4}{w^x_5}$. Finally, we can associate every
effect with the operation that generated the effect with the help of a relation
$\operZ$. In the current example, $\oper{w^x_4}{foo}$ and $\oper{w^x_5}{bar}$
hold. For simplicity, we assume that all the operation names across all object
types are distinct.

The system model described allows all the inconsistencies associated with
eventual consistency. The goal of our work is to identify the precise
consistency level for each operation such that the application-level
constraints are not violated. In the next section, we will concretely describe
the challenges associated with constructing a consistent bank account on top of
eventually consistent data stores. Subsequently, we will illustrate how our
contract language, armed with the primitive relations $\visZ$, $\soZ$,
$\sameobjZ$ and $\operZ$, mitigates these challenges.

\subsection{Eventually Consistent Bank Account}

Suppose our goal is to implement a highly available bank account on top of an
eventually consistent data store, with the \emph{integrity} constraint that the
balance should never drop below 0. Let us assume that the bank account object
provides three operations: \cf{deposit}, \cf{withdraw} and \cf{getBalance},
with the assumption that the withdraw fails if the account has insufficient
balance to complete the withdraw operation. Our goal is to choose the correct
consistency level for each operation such that (1) the balance never drops
below zero and (2) the \cf{getBalance} operation never incorrectly show a
negative balance. To be able to do this, we need to consider the anomalies that
could arise under eventual consistency.

\begin{figure}
\centering
\subfigure[Unsafe withdraw]{\label{fig:unsafeWithdrawAnomaly}\includegraphics[width=0.34\columnwidth]{Figures/Motivation4}}
\hfill
\subfigure[Negative balance]{\label{fig:negativeBalanceAnomaly}\includegraphics[width=0.31\columnwidth]{Figures/Motivation2}}
\hfill
\subfigure[Missing update]{\label{fig:missingUpdateAnomaly}\includegraphics[width=0.26\columnwidth]{Figures/Motivation1}}
\caption{Anomalies possible under eventual consistency for the get balance operation.}
\label{fig:cleanliness_examples}
\end{figure}

Consider the execution shown in Figure~\ref{fig:unsafeWithdrawAnomaly}. Assume
that all operations in the figure are on the same bank account object with
initial balance as 0. Session 1 performs a \cf{deposit} of 100, followed by a
\cf{withdraw} of 80 in the same session. The \cf{withdraw} operation witnesses
the deposit and succeeds\footnote{Although visibility and session order
relations relate effects, we have abused the notation in these examples to
relate operations, with the idea that the relations relate the effect emitted
by those operations}. Subsequently, session 2 perform a \cf{withdraw}
operation, but importantly, due to eventual consistency, only witnesses the
\cf{deposit} from session 1, but not the subsequent withdraw. Hence, this
\cf{withdraw} also \emph{incorrectly} succeeds, violating the integrity
constraint. A subsequent \cf{getBalance} operation, that witnesses all the
previous operations and reports a negative balance.

It is easy to see that the only way to ensure that integrity constraint on
\cf{balance} is to prevent concurrent withdrawals on the same bank account
object. This can be done by insisting that \cf{withdraw} be executed with
strong consistency. Although this prevents the integrity constraint from being
violated, a strongly consistent \cf{withdraw} itself is not sufficient to
prevent \cf{getBalance} from ever reporting a negative balance to the end user.

Consider the execution shown in fig.~\ref{fig:negativeBalanceAnomaly}, which
consists of three concurrent sessions performing a \cf{deposit}, a
\cf{withdraw}, and a \cf{getBalance} operation, respectively, on the same bank
account object. Assume that initial balance in the account is zero. As the
\cf{vis} edge indicates, operation \cf{withdraw(50)} in session 2, can
witnesses the effects of \cf{deposit(100)} from session 1, leading it to
rightfully conclude that the current balance is 100. Consequently,
\cf{withdraw(50)} is performed safely. The effect of this \cf{withdraw}
operation subsequently becomes visible to the \cf{getBalance} in Session 3.
However, \cf{getBalance}, which only witnesses the effect of \cf{withdraw} from
session 2, but not the \cf{deposit} from session 1, reports the balance of
negative 50 to the user.

Negative balance is not the only inconsistency that the user is exposed to
under an eventually consistent bank account. Figure
~\ref{fig:missingUpdateAnomaly} shows an execution where the \cf{getBalance}
operation in a session does not witness the effects of \cf{withdraw} operation
performed in the same session, possibly because \cf{getBalance} was served by a
replica that has not yet merged the \cf{withdraw} effect, served by a different
replica. This anomaly leads the user to incorrectly conclude that the
\cf{withdraw} operation failed to go through.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{Graphs/BankAccount_Th_vs_Lat}
\caption{Bank Account: Throughput vs Latency. Quelea is our implementation.
Strong and Quelea are correct. High. Avail. and causal are incorrect (withdraw
not strong). 20\% withdraw, 20\% deposit, 60\% getBalance.}
\label{grf:BankAcc_Th_vs_Lat}
\end{figure}


Although it is easy to understand the reasons behind the occurrence of the
aforementioned negative balance and missing update anomalies, the fix is not
quite apparent. Making \cf{getBalance} a strongly consistent operation is
definitely sufficient to avert anomalies, but is it really necessary? Given
that a strongly consistent operation is significantly expensive
(Figure~\ref{grf:BankAcc_Th_vs_Lat} \KC{Should I include the numbers here? If
yes, I'll expand the text.}), both in terms of availability and monetary
overheads~\cite{DynamoDB,Pileus}, we ideally would not want to request strong
consistency, unless there are no alternatives available. Unfortunately, this
requires us to understand subtle differences in semantics of various kinds of
weak consistency alternatives, offered by the data stores.

\subsection{Contracts}

\name automates this error-prone task by letting the programmer declare
application-level consistency constraints as \emph{contracts}. The key
intuition is that, in the case of the bank account example, any execution that
does not exhibit the anomalies described in the previous section is a
\emph{well-formed} execution on the bank account object. In the same vein as
axiomatic memory models for shared memory multicore
processors~\cite{Demange2013,Sarkar2011}, the programmer axiomatically
describes the set of legal executions on top of each replicated date type over
a trace of operation invocations on that type. Quelea ensures that any
execution on top of such datatypes always belongs to the set of well-formed
executions on that type.

In the bank account example, we observed that, in order to preserve the
integrity constraint, the \cf{withdraw} operation must be strongly consistent.
That is, given two \cf{withdraw} operations $a$ and $b$, either $a$ is visible
to $b$ or vice versa. Utilizing the primitive relations described in
Section~\ref{sec:sysmod}, we express this application-level consistency
requirement as a contract over \cf{withdraw}:
\begin{smathpar}
\begin{array}{l}
\forall (a : \rcf{withdraw}).~\sameobj{a}{\cureff} \Rightarrow a = \cureff \vee \vis{a}{\cureff} \vee \vis{\cureff}{a}
\end{array}
\end{smathpar}
In the above contract, $\cureff$ stands for the effect emitted by the
\cf{withdraw} operation. The syntax $a : \rcf{withdraw}$ states that $a$ is an
effect which was emitted by a \cf{withdraw} operation i.e)
$\oper{a}{\rcf{withdraw}}$ holds. The contract says that, if the current
operation emits an effect $\cureff$, then for any operation $a$ which was
emitted by a \cf{withdraw} operation, it is the case that $a = \cureff$ or $a$
is visible to $\cureff$ or vice versa. Any execution on a bank account object
that preserves the above contract for a \cf{withdraw} operation is said to have
a correct implementation of \cf{withdraw}.

For the \cf{getBalance}, we construct a contract  precisely to prevent the
anomalies described previously. The contract is shown below:
\begin{smathpar}
\begin{array}{l}
\forall (a:\rcf{deposit}), (b:\rcf{withdraw}), (c: \rcf{deposit} \vee \rcf{withdraw}). \\
\qquad \vis{a}{b} \wedge \vis{b}{\cureff} \Rightarrow \vis{a}{\cureff} \\
\qquad \wedge~ (\soZ \cap \sameobjZ) (c,\cureff) \Rightarrow \vis{c}{\cureff}
\end{array}
\end{smathpar}

If a \cf{withdraw} $b$ is visible to the get balance operation, then all
\cf{deposit} operations $a$ visible to the \cf{withdraw} should be visible to
the get balance operation. This prevents negative balance anomalies. The syntax
$c : \rcf{deposit} \vee \rcf{withdraw}$ states that $c$ is an effect that was
emitted either by a \cf{deposit} operation or by a \cf{withdraw} operation. The
contract language provides relational operators to compose relations. The
syntax $(R_1 \cap R_2)(a,b)$ is equivalent to $R_1(a,b) \wedge R_2(a,b)$. The
last line of the above contract says that if a \cf{deposit} or a \cf{withdraw}
precedes a \cf{getBalance} operation in session order, and is applied on the
same object as the \cf{getBalance} operation, then it must be the case that the
\cf{getBalance} operation witnesses the effects of the preceding operations.
Since the deposit operation does not have any restrictions, its contract is
simply $\true$.

\subsection{From Contracts to Implementation}

Notice that the contracts for \cf{withdraw} and \cf{getBalance} only express
the application-level consistency requirements, and make no reference to the
semantics of the underlying store. To write such contracts, a programmer only
needs to reason about the semantics of the application under the \name system
model. The mapping of application-level consistency requirements to appropriate
store-level guarantees is done automatically behind the screen.

How might one go about ensuring that any execution adheres to the contract? The
challenge is that contract is a declarative characterization of correctness of
execution, while what we need is an operational procedure for \emph{enforcing}
the contracts. One strategy is to adopt speculative execution as espoused by
other eventually consistent systems, where operations are tentatively applied
as they are received from the client or other replicas. We can maintain a
runtime manifestation of the axiomatic characterization and check the
well-formedness at runtime, and rollback the execution if
ill-formed~\cite{rxcml}. However, the overhead of state maintenance and the
complexity of user-defined contracts (unlike simple tests such as cyclic
dependence) make this technique unviable.

Instead, Quelea statically analyzes the contracts using an SMT solver, and maps
each operation to a particular store-level consistency under which the contract
would be preserved. In particular, the key idea is that the system implementor
axiomatically describes the store semantics in the same contract language as
the one used to express the contract on the operation. We translate the
contracts down to decidable subset of first-order logic~\cite{}, and discharge
proof obligation of checking whether a particular store consistency level is
sufficient for the given contract with the help of an SMT solver. The next
section describes the contract language and classification.
