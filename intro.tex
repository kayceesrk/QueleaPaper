\section{Introduction}

Many real-world web applications --- such as Amazon, Facebook, Google, Twitter
--- replicate application state and logic across multiple \emph{replicas} within
and across data centers. Replication is intended not only to improve application
throughput and reduce user perceived latency, but also to tolerate partial
failures without compromising the service availability. Traditionally
programmers have relied on \emph{strong consistency} guarantees, such as
Linerizability~\cite{Herlihy1990} or serializability~\cite{Serializability},
provided by the underlying data store in order to build correct applications.
While strong consistency is an easily stated property, it
masks the reality underlying large-scale distributed systems with respect to
non-uniform latency (i.e., availability) and network
partitions~\cite{Brewer2000,Gilbert}. Indeed, modern web applications, which aim to provide
an "always on" experience, overwhelmingly embrace availability and partition
tolerance at the expense of strong consistency. 

Nevetheless, to avoid exposing end user to absurdities such as negative balances
in a bank account, or an item appearing in the shopping cart after it had been
removed~\cite{Dynamo}, web applications \emph{do} require some level of
consistency guarantees from the underlying data store. Accordingly, many
commercial~\cite{} and research~\cite{} systems provide guarantees that are
weaker than strong consistency, such as eventual consistency, causal
consistency, session guarantees, and time line consistency. Each such \emph{weak
consistency} guarantee imposes certain amount of penalty on the availability
(hence, latency and throughput) of the system depending on the extent of
inter-replica coordination required to ensure the guaranteed level of
consistency. It is therefore incumbent on the application programmer to
carefully reason about concurrent conflicting updates, and select the
appropriate store-level weak consistency guarantee sufficient for preserving
application-level integrity properties, while minimizing the adverse impact on
the availability of the application. Understandably, this is an error prone
process as the user not only has to understand the intricate behavior of the
application, but also the semantics of the underlying store consistency levels,
which are often presented informally~\cite{}.

%--KC--
% The choice of correct consistency level is critical to the correctness and
% scalability of the application. Choosing a weaker consistency level than
% required introduces anomalies, while choosing a stronger than necessary level
% affects program scalability.
\KC{Do we include the LWW-Register number here to add emphasis to the fact that
choosing the correct consistency level is essential for program scalability}.

Moreover, weak consistency hinders compositional reasoning about programs.
While an application might be naturally expressed in terms of well-understood
abstract data types, such as dictionaries, counters, queues, and graphs,
geo-distributed stores typically only provide a minimal set of data types with
in-built conflict resolution strategy such as last-writer-wins (LWW) registers,
counters and sets~\cite{Cassandra,DynamoDB}.  Furthermore, while traditional
database systems enable composability through transactions, existing
geo-distributed stores lack unrestricted transactional access to the data.
Working with geo-distributed stores thus requires application state to be
suitably coerced to work within the capabilities of the store.


To address these issues, we introduce \name, a declarative programming system
for eventually consistent data stores. \name's programming model is built around
operation-based Commutative Replicated Data Types (CRDTs) ~\cite{shapiroCRDT}.
The state of an abstract data type in \name is modeled as a replicated
\emph{append-only} log storing the history of \emph{update} operations performed
on the data type . For instance, the state of a replicated counter ADT is stored
on all replicas as a log of \emph{increment} and \emph{decrement} operations
performed on the counter. An operation that indends to read the current value
the counter at a replica only has to \emph{fold} over the history log at that
replica. Our key observation is that under this model, consistency requirements
of a replicated data type operation (eg: \emph{decrement}) can be expressed
effectively in terms of assertions on \emph{membership} property of logs at
various replicas. \name makes use of this observation to introduce a simple
\emph{contract language} that is nevertheless capable of expressing fine-grained
application-level consistency properties.  The contract language is made up of a
couple of primitive relations, namely \emph{visibility} and \emph{session
order}, and a carefully choosen set of logical operators. \name expects
application programmer to use the contract language to describe the set of legal
executions allowed over the replicated data types.  
% The executions descriptions are similar to the high-level axiomatic
% description of relaxed memory models~\cite{Demange2013}.
Subsequently, a contract enforcement system logically analyses contracts using
an SMT solver~\cite{z3} and automatically tags each operation with the weakest
store-level consistency guarantee that is required to satisfy application-level
consistency requirements. In addition, the system statically reports an error if
the given application-level consistency property cannot be satisfied by the
store. 

The paper makes the following contributions:

\begin{itemize}

\item We introduce \name, a language for declaratively describing eventually
  consistent programs that manipulate replicated data types. Contracts are
  used to specify fine-grained application-level consistency properties, and
  are analyzed to assign the most efficient and sound store consistency
  level to the corresponding operation.

\item \name supports coordination-free transactions over arbitrary
  datatypes.  We extend our contract language to express fine-grained
  transaction isolation guarantees, and utilize the contract enforcement
  system to automatically assign the correct and most efficient isolation
  level for a transaction.

\item Metatheory that certifies the soundness of our contract enforcement
  system, and ensures that an operation is only executed if the required
  conditions on consistency are met is also given.

\item \name is implemented as a shim layer over (and importantly without
  modifying) Cassandra, a well-known general-purpose data store.  An
  extensive experimental evaluation over a collection of real-world
  applications, including a Twitter-like micro-blogging site and an
  eBay-like auction site illustrates the practicality of our approach.

\end{itemize}

The rest of the paper is organized as follows. Section~\ref{sec:motivation}
motivates \name and introduces the language through a series of examples.
Section~\ref{sec:lang} describes the contract language, and
Section~\ref{sec:opsem} presents an operational semantics.
Section~\ref{sec:txns} introduces transaction contracts and
classification. Section~\ref{sec:impl} describes the implementation and goes
into detail about the optimizations needed to make the system practical.
Section~\ref{sec:results} discusses experimental evaluation.
Section~\ref{sec:related} and~\ref{sec:concl} present related work and
conclusions.
