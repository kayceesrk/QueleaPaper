\section{Introduction}

Many real-world web services --- such as Amazon, Facebook, Google, Twitter ---
replicate application state and logic across multiple \emph{replicas} within
and across data centers. Replication is intended not only to improve
application throughput and reduce user perceived latency, but also to tolerate
partial failures without compromising the service availability. Traditionally
programmers have relied on \emph{strong consistency} guarantees such as
Linerarizability~\cite{Herlihy1990} or serializability~\cite{Serializability}
in order to build correct applications. While strong consistency is simple to
reason about, the CAP theorem~\cite{Brewer2000,Gilbert} makes it impossible for
a system to achieve strong consistency, tolerate network partitions and remain
highly available. Thus, modern web services, which aim to provide an "always
on" experience, overwhelmingly embrace availability and partition tolerance
over strong consistency. Several \emph{weak consistency} models such as
eventual consistency, causal consistency, session guarantees, and time line
consistency have been proposed.

Under weak consistency, the programmer needs to be aware of concurrent
conflicting updates, and has to pay careful attention to avoid inconsistencies
such as negative balances in a bank account, and an item appearing in the
shopping cart after it has been removed~\cite{Dynamo}. Often times, the
inconsistency leaks from the application and is witnessed by the user. To
address this issue, many commercial~\cite{} and research~\cite{} systems
propose guarantees that are weaker than strong consistency, and hence need only
to contact a subset of replicas for discharging the operations. With these
alternatives, it is up to the programmer to decide whether a weaker consistency
level is sufficient for a preserving the application-level consistency
properties. Understandably, this is an error prone process as the user not only
has to understand the intricate behavior of the application, but also the
semantics of the underlying store consistency levels, which are often presented
informally~\cite{}.

%--KC--
% The choice of correct consistency level is critical to the correctness and
% scalability of the application. Choosing a weaker consistency level than
% required introduces anomalies, while choosing a stronger than necessary level
% affects program scalability.
\KC{Do we include the LWW-Register number here to add emphasis to the fact that
choosing the correct consistency level is essential for program scalability}.

Moreover, weak consistency hinders compositional reasoning about programs.
While the application might be naturally expressed as maps, trees, counters,
queues, or graphs, geo-distributed stores are typically only provide a minimal
set of data types with in-built conflict resolution strategy such as
last-writer-wins (LWW) register, counters and sets~\cite{Cassandra,DynamoDB}.
While traditional database systems enable composability through transactions,
the state-of-the-art geo-distributed stores lack unrestricted transactional
access to the data. Indeed, traditional database systems do offer a variety of
transaction isolation levels~\cite{}, each with a particular runtime overhead,
leaving the choice of correct consistency level to the programmer. Thus, the
programmer working with geo-distributed stores has but to coerce the
application state to the data store capabilities.

To address these issues, we introduce Quelea, a declarative programming model
for eventually consistent stores. The key novelty of Quelea is a \emph{contract
language} to express the fine-grained application-level consistency properties.
The programmer uses the contract language to describe the set of legal
executions allowed over the replicated data types. The contracts are
constructed using primitive relations such as \emph{visibility} and
\emph{session order} and a carefully chosen set of logical operators. The
executions descriptions are similar to the high-level axiomatic description of
relaxed memory models~\cite{Demange2013}. A contract enforcement system
logically analyses the contracts using an SMT solver~\cite{} and automatically
maps each operation to one of the store consistency levels. In addition, the
system statically reports an error if the given application-level consistency
property cannot be satisfied by the store. The paper makes the following
contributions:

\begin{itemize}

\item We introduce Quelea, a language for declaratively describing eventually
consistent programs. Replicated data types in Quelea are defined as reductions
over the set of previously seen updates on an object; new updates are simply
appended to this set. Quelea is equipped with a contract language to describe
fine-grained application-level consistency properties. The contracts are
logically analyzed, and the corresponding operations are automatically assigned
to the most efficient store consistency level under which the application-level
contracts are guaranteed to hold.

\item Quelea supports coordination-free transactions over arbitrary datatypes.
We extend our contract language to express fine-grained transaction isolation
guarantees, and utilize the contract enforcement system to automatically assign
the correct and most efficient isolation level for a transaction.

\item We present meta-theory that certifies the soundness of our contract
enforcement system, and ensures that an operation is only executed if the
required conditions on consistency are met.

\item Quelea is implemented as a shim layer over (and importantly without
modifying) Cassandra, a general-purpose data store, illustrating the
portability of our approach. An extensive experimental evaluation over a
collection of real-world applications, including a Twitter-like micro-blogging
site and an ebay-like auction site illustrates the practicality of our
approach.

\end{itemize}

The rest of the paper is organized as follows. Section~\ref{sec:motivation}
motivates Quelea and introduces the language through a series of examples.
Section~\ref{sec:lang} presents the contract language, and
section~\ref{sec:opsem} presents the operational semantics of the Quelea
runtime system. Section~\ref{sec:txns} introduces transaction contracts and
classification. Section~\ref{sec:impl} describes the implementation and goes
into detail about the optimizations needed to make the system practical.
Section~\ref{sec:results} present the experimental evaluation.
Section~\ref{sec:related} and~\ref{sec:concl} discuss the related work and
conclusions.
