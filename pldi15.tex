%
% LaTeX template for prepartion of submissions to PLDI'15
%
% Requires sigplanconf style file provided on PLDI'15 web site
%
\documentclass[pldi]{sigplanconf}

%
% the following standard packages may be helpful, but are not required
%
\usepackage{SIunits}            % typset units correctly
\usepackage{courier}            % standard fixed width font
\usepackage[scaled]{helvet} % see www.ctan.org/get/macros/latex/required/psnfss/psnfss2e.pdf
\usepackage{url}                  % format URLs
\usepackage{listings}          % format code
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}   % print a hyperlinked DOI



\begin{document}

%
% any author declaration will be ignored  when using 'plid' option (for double blind review)
%

\title{Declarative Programming over Eventually Consistent Databases }

\maketitle
\begin{abstract}
User-facing online services utilize geo-distributed data stores to minimize
latency and tolerate partial failures, with the intention to provide a fast,
always-on experience. However, geo-distribution does not come for free;
application developers have to contend with weak consistency behaviors, and the
lack of abstractions to composably construct high-level replicated data types,
neccesitating complex application logic and invariably exposing inconsistencies
to the user. Commercial distributed data stores and sevaral academic proposals
do propose a lattice of stronger consisteny levels. However, assigning the
correct consistency level for an operation is a error prone task.

In this paper, we present Quelea, a declarative programming model for
eventually consistent data stores. Quelea allows expressive convergent
replicated data types to be defined over an append-only set abstraction. Quelea
is equipped with a \emph{contract} language, capable of expressing fine-grained
application-level consistency properties. A \emph{contract enforcement system}
logically analyses the contracts using an SMT solver, and automatically maps it
to the store's consistency level. We describe an implementation of Quelea on
top of an off-the-shelf eventually consistent data store, and support
coordination-free transactions. Several benchmarks including two large web
applications, illustrate the effectiveness of our approach.
\end{abstract}

\section{Introduction}

Many real-world web services --- such as Amazon, Facebook, Google, Twitter ---
replicate application state and logic across multiple \emph{replicas} within
and across data centers. Replication is intended not only to improve
application throughput and reduce user perceived latency, but also to tolerate
partial failures without compromising the service availability. Traditionally
programmers have relied on \emph{strong consistency} guarantees such as
Linerarizability~\cite{Herlihy1990} or serializability~\cite{Serializability}
in order to build correct applications. While strong consistency is simple to
reason about, the CAP theorem~\cite{Brewer2000,Gilbert} makes it impossible for
a system to achieve strong consistency, tolerate network partions and remain
highly available. Thus, modern web services, which aim to provide an "always
on" experience, overwhelmingly embrace availability and partition tolerance
over strong consistency. Several \emph{weak consistency} models such as
eventual consistency, causal consistency, session guarantees, and timeline
consistency have been proposed.

Under weak consistency, the programmer needs to be aware of concurrent
conflicting updates, and requires careful attention to avoid inconsistencies
such as negative balances in a bank account, and an item appearing in the
shopping cart after it has been removed~\cite{Dynamo}. Often times, the
inconsistency leaks from the application and is witnessed by the user. To
address this issue, many commercial~\cite{} and research~\cite{} systems
propose guarantees that are weaker than strong consistency, and hence need only
to contact a subset of replicas for discharging the operations. Indeed,
traditional database systems do provide a variety of transaction isolation
levels~\cite{}, each with a particular runtime overhead. With these
alternatives, it is upto the programmer to decide whether a weaker consistency
level is sufficient for a preserving the application-level consistency
properties. Understandably, this is an error prone process as the user not only
has to understand the intricate behavior of the application, but also the
semantics of the underlying store consistency levels, which are often presented
informally~\cite{}.

Moreover, weak consistency hinders compositional reasoning about programs.
While the application might be naturally expressed as maps, trees, counters,
queues, or graphs, geo-distributed stores are typically only provide a minimal
set of data types with in-built conflict resolution strategy such as
last-writer-wins (LWW) register, counters and sets~\cite{Cassandra,DynamoDB}.
Unlike traditional database systems, the geo-distributed stores typically lack
unrestricted transactional access to the data. Thus, the application developer
often has to coerce the application state to the data store capabilities.

To address these issues, we introduce Quelea, a declarative programming model
for eventually consistent stores. The key novelty of Quelea is a \emph{contract
language} to express the fine-grained application-level consistency properties.
The programmer uses the contract language to describe the set of legal
executions allowed over the replicated data types. The contracts are
constructed using primitive relations such as \emph{visibility} and
\emph{session order} and a carefully chosen set of logical operators. The
executions descriptions are similar to the high-level axiomatic decription of
relaxed memory models~\cite{Demange2013}. A contract enforcement system
logically analyses the contracts using an SMT solver~\cite{} and automatically
maps each operation to one of the store consistency levels. In addition, the
system statically reports an error if the given application-level consistency
property cannot be satisfied by the store. The paper makes the following
contributions:

\begin{itemize}

\item We introduce a data type definition language that allows the programmer
to describe their own convergent replicated data types. The data type
operations are defined as reductions over the set of all updates to a
particular object. New updates are simply appended to the existing set. This
expressive model lets the programmer implement their own convergence policy.

\item We present a contract language for describing fine-grained
application-level consistency properties, which is statically analyzed by a
contract enforcement system, and automatically assigns the operations to the
most efficient store consistency level, under which the application-level
contracts are guaranteed to hold.

\item We support coordination-free transactions over arbitrarty datatypes. We
extend our contract language to express fine-grained transaction isolation
guarantees, and utilize the contract enforcement system to automatically assign
the correct and most efficient isolation level for a transaction.

\item We present meta-theory that certifies the soundness of our contract
enforcement system, and ensures that an operation is only executed if the
required conditions on consistency are met.

\item We present extensive experimental evalation over a collection of
real-world applications, including a Twitter-like microblogging site and an
ebay-like auction site.

\end{itemize}

The rest of the paper is organized as follows. Section~\ref{sec:motivation}
motivates Quelea and introduces the system through a series of examples.
Section~\ref{sec:lang} presents the contract language, and
section~\ref{sec:opsem} presents the operational semantics of the Quelea
runtime system. Section~\ref{sec:txns} introduces transaction contracts and
classification. Section~\ref{sec:impl} describes the implementation and goes
into detail about the optimizations needed to make the system practical.
Section~\ref{sec:results} present the experimental evaluation.
Section~\ref{sec:related} and~\ref{sec:concl} discuss the related work and
conlusions.

\end{document}
