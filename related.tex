\section{Related Work}
\label{sec:related}

Operation-based RDTs have been widely studied in terms of their algorithmic
properties~\cite{SSS,Burckhardt2014}, and several systems utilize this model to
construct distributed data structures~\cite{Cassandra,Bayou,Tango}. These
systems typically propose to implement the datatypes directly over a cluster of
nodes, and only focus on basic eventual consistency. Hence, these systems
implement custom solutions for durability and fault-tolerance. \name realizes
RDTs stronger consistency models on top of off-the-shelf eventually consistent
distributed stores. In this respect, \name is similar to~\cite{BoltOn} where
causal consistency is achieved through a shim layer on Cassandra, which
explicitly tracks and enforces dependencies between updates.
However,~\cite{BoltOn} does not support user-defined RDTs, automatic contract
classification and transactions.

Since eventual consistency alone is insufficient to build correct applications,
several systems~\cite{Bayou,Pileus,RedBlue} propose a lattice of stronger
consistency levels. Similarly, traditional database processing
systems~\cite{Berenson95} and their replicated variants~\cite{BailisHAT}
propose weaker isolation levels for performance. In these systems, the onus is
on the developer to choose the correct consistency(isolation) level for
operations(transactions). \name relieves the developer of this burden, and
instead expects contracts expressing declarative visibility requirements.

Our contract language is inspired by the axiomatic description of RDT semantics
proposed by~\cite{Burckhardt2014}. While they use axioms for formal
verification of correctness of an RDT implementation, we utilize them as a
means for the user to express the desired consistency guarantees in the
application. Similar to their work, our contract language does not incorporate
real (i.e., wall-clock) time. Hence, it cannot describe store semantics such as
recency or bounded-staleness guarantees offered by certain
stores~\cite{Pileus}.

Several conditions have been proposed to judge whether an operation on a
replicated data object needs coordination or not. ~\cite{Calm} defines
\emph{logical monotonicity} as a sufficient condition for coordination freedom,
and proposes a consistency analysis that marks code regions performing
non-monotonic reasoning (eg: aggregations, such as \cf{COUNT}) as potential
coordination points.  ~\cite{IConfluence} and ~\cite{Sieve} define
\emph{invariant confluence} and \emph{invariant safety}, respectively, as
conditions for safely executing an operation without coordination. ~\cite{Sieve}
also proposes a program analysis that conservatively marks certain operations as
\emph{blue} (coordination not required), while marking the remaining as
\emph{red} (coordination required). Unlike \name, these works focus on a
coarse-grained classification of consistency as eventual or strong, and do not
focus on transaction isolation levels. However, program analyses they propose
relieve programmers of the burden to tag operations with consistency levels.
Indeed, we do consider automatic inference of consistency contracts from
application-specific integrity constraints as the next step for \name.
