\section{Related Work}
\label{sec:related}

Operation-based RDTs have been widely studied in terms of their algorithmic
properties~\cite{SSS,Burckhardt2014}, and several systems utilize this model to
construct distributed data structures~\cite{Cassandra,Bayou,Tango}. These
systems typically propose to implement the datatypes directly over a cluster of
nodes, and only focus on basic eventual consistency. Hence, these systems
implement custom solutions for durability and fault-tolerance. \name realizes
RDTs stronger consistency models on top of off-the-shelf eventually consistent
distributed stores. In this respect, \name is similar to~\cite{BoltOn} where
causal consistency is achieved through a shim layer on Cassandra, which
explicitly tracks and enforces dependencies between updates.
However,~\cite{BoltOn} does not support user-defined RDTs, automatic contract
classification and transactions.

Since eventual consistency alone is insufficient to build correct applications,
several systems~\cite{Bayou,Pileus,RedBlue} propose a lattice of stronger
consistency levels. Similarly, traditional database processing
systems~\cite{Berenson95} and their replicated variants~\cite{BailisHAT}
propose weaker isolation levels for performance. In these systems, the onus is
on the developer to choose the correct consistency(isolation) level for
operations(transactions). \name relieves the developer of this burden, and
instead expects programmers to declare application-specific consistency
requirements as first-order formulas. In this regard, \name is similar to Indigo
\cite{indigo}, which requires programmers to declare application-specific
invariants that are expected to be met, along with pre- and post-conditions on
operations as formulas in first-order logic. Indigo then performs a static
analysis on formulas to identify $I$-offender sets - sets of operations,
which, when performed concurrently, result in violation of one or more of the
stated invariants. For each offending set of operation, if programmer chooses 
invariant-violation avoidance over violation repair, the system employs various
techniques, such as escrow reservation, to ensure that the offending set of
operations are never run concurrently.

While serializing operations is sufficient to ensure that the application state
never violates invariants (e.g: \cf{balance $\ge$ 0}), there exist a range of
desirable application-level properties, which cannot be captured in Indigo's
specification language, or for which serialization is an overkill. For instance,
it is neither efficient nor straightforward in Indigo to declare and enforce a
condition to prevent the missing update anomaly
(Figure~\ref{fig:missingUpdateAnomaly}) in the bank account application. The
only way is to encode specifications of all bank account operations such that
every pair of operations are identified as $I$-offending, for some invariant
($I$), resulting in them being serialized. In contrast, \name's contract
language allows for precise encoding of the desired property, and the contract
classification scheme ensures that the it can be enforced without the need to
serialize operations. Furthermore, Indigo also does not distinguish between
various transaction isolation guarantees, which \name does.

Our contract language is inspired by the axiomatic description of RDT semantics
proposed by~\cite{Burckhardt2014}. While they use axioms for formal
verification of correctness of an RDT implementation, we utilize them as a
means for the user to express the desired consistency guarantees in the
application. Similar to their work, our contract language does not incorporate
real (i.e., wall-clock) time. Hence, it cannot describe store semantics such as
recency or bounded-staleness guarantees offered by certain
stores~\cite{Pileus}.

Several conditions have been proposed to judge whether an operation on
a replicated data object needs coordination or not. ~\cite{Calm}
defines \emph{logical monotonicity} as a sufficient condition for
coordination freedom, and proposes a consistency analysis that marks
code regions performing non-monotonic reasoning (eg: aggregations,
such as \cf{COUNT}) as potential coordination points.
~\cite{IConfluence} and ~\cite{Sieve} define \emph{invariant
confluence} and \emph{invariant safety}, respectively, as conditions
for safely executing an operation without coordination. ~\cite{Sieve}
also proposes a program analysis that conservatively marks certain
operations as \emph{blue} (coordination not required), while marking
the remaining as \emph{red} (coordination required). Unlike \name,
these works focus on a coarse-grained classification of consistency as
eventual or strong, and do not focus on finer-grained transaction
isolation levels. However, the analyses they propose relieve
programmers of the burden to tag operations with consistency levels.
Indeed, we do consider automatic inference of consistency contracts
from application-specific integrity constraints as the next step for
\name.
