\section{Operational Semantics}
\label{sec:store-opsem}

\renewcommand{\auxred}[4]{#1 \vdash #2 \;\xhookrightarrow{#3}\; #4 }

We now describe operational semantics of a data store that implements
strong, causal and eventual consistency guarantees. The semantics also
serves as a high-level description of our implementation of the store
underlying \name.

% Semantics
% ---------
\input{store-opsem-rules}

Figure ~\ref{sem:oper} presents operational semantics as rules
defining the reduction relation ($\xrightarrow{}$) over the execution
state.  Since we now have a concrete store, we extend our system model
with $\Theta$, a representation of the store as a map from replicas to
their local states. The local state of a replica $r$ (i.e.,
$\Theta(r)$) is a set of effects that are currently visible at $r$.
An operation $op$ performed at replica $r$ can only witness the set of
effects ($\Theta(r)$) visible at $r$. To avoid too many parentheses in
our formal presentation, we represent operation $op$, whose contract
is in consistency class $\tau$, as $op_\tau$ instead of the usual
$\langle op,\tau \rangle$. For the sake of clarity, we only
consider a single replicated object of well-defined type (for eg: a
replicated object of type \cf{BankAccount}) in our formalization.  Our
semantics are parametric over the specification of this replicated
data type. Figure~\ref{sem:oper} formalizes replicated data type (RDT)
specification as tuple $(\delta,\Ops,\Ctrts)$, where $\delta$ is the
data type, $\Ops$ maps labels ($op$) of operations on $\delta$ to
their definitions, while $\Ctrts$ maps them to their consistency
contracts ($\cv$). The definition of an operation is expected to be a
lambda expression, although we do not enforce this in our
formalization. For technical reasons, we tag each session with a
session identifier ($s$) and the sequence number ($i$) of the next
operation in the session.

The state of an operational execution ($\E$) is a tuple \Exec, where
$\EffSoup$ is a set of effects, and $\visZ$, $\soZ$, $\sameobjZ$
$\subseteq$ $\EffSoup \times \EffSoup$ are \emph{visibility},
\emph{session order}, and \emph{same object} relations over effects,
respectively. We define an effect ($\eff$) as a tuple
$(s,i,op,v)$, which records the fact that $i^{th}$ action in session
with {\sf SessID} $s$, which is an operation $op$ on the replicated
object, has been successfully executed on some replica yielding a
return value $v$. Note that the combination of $s$ and $i$ uniquely
identifies the effect. Session order relation ($\soZ$) relates effects
generated by the same session.  An effect $\eff = (s,i,op,v)$ is said
to precede another effect $\eff' = (s',i',op',v')$ in session order if
and only if $s'=s$ and $i'\ge i$. Since we only consider one
replicated object in our formalization, the $\sameobjZ$ relation
relates every pair of effects in the effect soup ($\EffSoup$). An
effect generated at a replica becomes visible at rest of the replicas
eventually.  If we denote the effect generated by the operation $op$
as $\eff_{op}$, then $\Theta(r) \times \{\eff_{op}\} ~\subseteq~
\visZ$. Often, in our formalization, we use $\visZ$ and $\soZ$ binary
relations to obtain a set of effects visible to a given effect $\eff$,
or set of effects that precede a given effect $\eff$ in the session
order. As a syntactic convenience, whenever $R$ is a binary relation,
we write $R(\eff)$ to denote the set of all $\eff'$ such that
$(\eff,\eff') \in R$.  Conversely, we write $R^{-1}(\eff)$ to denote
the set of all $\eff'$ such that $(\eff',\eff) \in R$.

Basic guarantee provided by the store is causal visibility, which is
captured by the rule $\rulelabel{EffVis}$ as a condition for an effect
to be visible at a replica. The rule makes an effect ($\eff$) visible
at a replica $r$ only after all the effects that causally precede
$\eff$ are made visible at $r$.  It is important to note that that
enforcing causal visibility does not require any inter-replica
coordination. Any eventually consistent store can provide causal
visibility while being eventually consistent.  Therefore, we do not
lose any generality by assuming that the store provides causal
visibility.

Rule $\rulelabel{Oper}$ is an auxiliary reduction of the
form:\vspace{-1.7mm}
\begin{smathpar}
\auxred{\Theta} {(\E,\langle s,i,op \rangle)} {r} {(\E',\eff)}
\vspace{-1.7mm}
\end{smathpar}
\noindent Under the store configuration $\Theta$, the rule captures
the progress in execution (from $\E$ to $\E'$) due to the application
of operation $op$ to replica $r$ resulting in a new effect $\eff$.
The rule first constructs a \emph{context} for the application from
the local state ($\Theta(r)$) of the replica, by
projecting\footnote{{\textsf{ctxt*}} is auxiliary function
\textsf{ctxt} extended straightforwardly to set of effects} relevant
information from effects in $\Theta(r)$. It then substitutes the
definition ($\Ops(op)$) of the operation for its label ($op$), and
relies on the reduction relation ($\rdtredsto$) of the server-side
language to reduce the application $\Ops(op)(ctxt)$ to a value $v'$.
Subsequently, the the attributes of execution state, namely
$\EffSoup$, $\visZ$, $\soZ$, and $\sameobjZ$ are extended to
incorporate the new effect ($\eff$).

If the operation $op$ is {\sf EventuallyConsistent}, we simply apply
the operation to any replica $r$. Since the store provides causal
visibility, eventually consistent operations are satisfiable under any
replica. If the operation is {\sf CausallyConsistent}, the operation
can be applied to a replica $r$ only if it already contains the
effects of all the previous operations from the same session. This
guarantee can be satisfied by applying all operations from the same
session to the same logical copy of the database.  If such a logical
copy is untenable, then the operation might block. Since the store is
assumed to converge eventually, the blocked causally consistent
operation guaranteed to unblock eventually.

A {\sf StronglyConsistent} operation expects sequential consistency.
That is, universe of all effects ($\EffSoup$) in an execution ($\E$)
must be partitionable into a set of effects that \emph{happened
before} $\eff$ and another set that \emph{happened after} $\eff$,
where $\eff$ is the effect generated by an strongly consistent
operation. The rule $\rulelabel{SC}$ enforces this sequencing in two
steps; firstly, it insists that the the strongly consistent operation
($op$) witness effects of all operations executed so far by requiring
the global set of effects $\EffSoup$ to be a subset of local state
($\Theta(r)$) of the replica ($r$) executing $op$. Secondly, the rule
requires the effect ($\eff$) generated by $op$ to be added to the
local state of every other replica in the store, so that further
operations on these replicas can witness the effect of $op$. Since
both these steps require global coordination among replicas, the store
is \emph{unavailable} during the time it is executing $op$.
% However, it must be noted that executing strongly consistent
% operation does not entail the convergence of local states of all
% replicas; it simply means that there is one replica ($r$) whose
% local state is the upper bound of local states of all replicas, and
% there exists a set containing atleast one effect ($\eff$), which is
% their lower bound.

\subsection{Soundness of Operational Semantics}

We now prove a meta-theoretic property that establishes the soundness
of our operational semantics in enforcing $\ecc$, $\ccc$, and $\scc$
consistency guarantees at every reduction step. As a corollary of this
result, and Theorem~\ref{thm:classification-sound}, we have the
assurance that \name correctly enforces all well-formed consistency
contracts.

First, we prove a useful lemma:

\input{auxred-wf-proof}

We now define causal consistency property of the store formally:

\begin{definition}
  A store $\Theta$ is said to be causally consistent under an execution
  $\E=\Exec$ if and only if:
  \begin{smathpar}
  \begin{array}{cr}
    \hspace*{-0.5in}\forall (r\in{\sf dom}(\Theta)). \forall (\eff \in
      \Theta(r)). & \\
    \hspace*{0.3in}\forall (a\in \EffSoup). \hbo{a}{\eff} \Rightarrow a 
      \in \Theta(r) & H\npp \\
  \end{array}
  \end{smathpar}
  Where, $\hboZ = (\Rvis \cup \sooZ)^{+}$
\end{definition}

The following theorem proves that our operational semantics correctly
enforce $\ecc$, $\ccc$, and $\scc$ guarantees:

% Main Theorem
% ------------
\input{soundness-theorem-proof}

We now show that every configuration of the store that is reachable
via the reduction relation ($\xrightarrow{}$) is causally consistent.

\input{causal-consistency-proof}

\begin{corollary}[Soundness]
  \label{thm:soundness}
  For every well-formed execution state $\E$, for every store $\Theta$
  that is causally consistent under $\E$, for every contract class $\tau
  \in \{{\sf ec},{\sf cc},{\sf sc}\}$, and for every consistency
  contract $\cv$ in the contract class $\tau$, If:
  \begin{smathpar}
  (\E, \Theta, \langle s,i,op_\tau :: 
  \sigma \rangle \pll \Sigma) \xrightarrow{\eff} (\E', \Theta',
  \langle s,i+1,\sigma \rangle \pll \Sigma)
  \end{smathpar}
  then (\romannumeral 1) $\E'$ is well-formed, (\romannumeral 2)
  $\Theta'$ is causally consistent under $\E'$, and (\romannumeral 3)
  $\E' \models \cv[\eff/\cureff]$
\end{corollary}
\begin{proof}
  Follows from Theorems \ref{thm:classification-sound},
  \ref{thm:local-state-is-cc}, and \ref{thm:weak-soundness}.
  \hfill \qed
\end{proof}



