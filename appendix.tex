\section{Appendix}
\label{sec:appendix}

\subsection{Soundness of Contract Classification} 

We restate theorem ~\ref{thm:classification-sound} and provide its proof
below:

\begin{theorem}[Soundness of Contract Enforcement]
\label{lem:classification-sound}
Let $\cv$ be a well-formed contract of a replicated data type
operation $\mathit{op}$, and let $\tau$ denote the consistency class
of $\cv$ as determined by the contract classification scheme. For all
well-formed execution states $\E$, $\E'$ such that $\auxred{}
{\E,\langle op,\tau \rangle;\sigma \pll \Sigma} {\eff} {\E', \sigma
\pll \Sigma}$, if $\E' \models \cv_\tau[\eff/\cureff]$, then $\E'
\models \cv[\eff/\cureff]$
\end{theorem}
\begin{proof}
  Hypothesis:
  \begin{smathpar}
  \begin{array}{cr}
    \auxred{} {\E,\langle op,\tau \rangle;\sigma \pll \Sigma} {\eff}
    {\E', \sigma \pll \Sigma} & H\npp\\
    \E' \models \cv_\tau[\eff/\cureff] & H\npp\\
  \end{array}
  \end{smathpar}
  Since $\tau$ is the contract class of $\cv$, by inversion, we have
  $\cv \le \cv_\tau$. By the definition of $\le$ relation:
  \begin{smathpar}
  \begin{array}{cr}
    \Delta \vdash \forall \cureff.\,\cv_\tau \Rightarrow \cv & H\npp\\
  \end{array}
  \end{smathpar}
   Since $\eff$ denotes new effect, it is a fresh variable that does
   not occur free in $\Delta$. From $H2$, after instantiating bound
   $\cureff$ with $\eff$, we have:
  \begin{smathpar}
  \begin{array}{cr}
    \Delta \vdash \cv_\tau[\eff/\cureff] \Rightarrow \cv[\eff/\cureff] 
      & H\npp\\
  \end{array}
  \end{smathpar}
  Due to the soundness of natural deduction for first-order logic,
  $H3$ implies that for all models $\mathcal{M}$ such that
  $\mathcal{M} \models \Delta$, if $\mathcal{M} \models
  \cv_\tau[\eff/\cureff]$ then $\mathcal{M} \models
  \cv[\eff/\cureff]$. Since $\E'$ is well-formed, we have:
  \begin{smathpar}
  \begin{array}{cr}
    \E' \models \Delta & H\npp\\
  \end{array}
  \end{smathpar}
  Proof follows from $H1$ and $H4$.
  \qed
\end{proof}

\subsection{Axiomatic Semantics}
\renewcommand{\auxred}[4]{#1 \vdash #2 \;\xhookrightarrow{#3}\; #4 }

We now describe axiomatic semantics of a data store that implements
strong, causal and eventual consistency guarantees. The semantics also
serves as an elegant representation of our implementation of \name.

Figure ~\ref{sem:oper} presents our semantics as concretization of the
rewrite relation ($\xrightarrow{}$) over execution state. Since we now have a
concrete store, we extend our system model with $\Theta$, a representation of
the store as a map from replicas to their local states. The local state of a
replica $r$ (i.e., $\Theta(r)$) is a set of effects that are currently
visible at $r$.  An operation $op$ performed at replica $r$ can only witness
the set of effects ($\Theta(r)$) visible at $r$. For the sake of clarity, we
only consider a single replicated object of well-defined type (for eg: a
replicated object of type \cf{BankAccount}) in our formalization.  Our
semantics are parametric over the specification of this replicated data type.
Figure~\ref{sem:oper} formalizes replicated data type (RDT) specification as
tuple $(\delta,\Ops,\Ctrts)$, where $\delta$ is the data type, $\Ops$ maps
labels ($op$) of operations on $\delta$ to their definitions, while $\Ctrts$
maps them to their consistency contracts ($\cv$). The definition of an
operation is expected to be a lambda expression, although we do not enforce
this in our formalization. For technical reasons, we tag each session with a
session identifier ($s$) and the sequence number ($i$) of the next operation
in the session. 

The state of an axiomatic execution ($\E$) is a tuple $\Exec$ where $\EffSoup$
is a set of effects, and $\visZ,\soZ, \sameobjZ \subseteq \EffSoup \times
\EffSoup$ are \emph{visibility}, \emph{session order}, and \emph{same object}
relations over effects, respectively. We concretize an effect ($\eff$) as a
tuple $(s,i,op,v)$, which records the fact that $i^{th}$ action in session
with {\sf SessID} $s$, which is an operation $op$ on the replicated object,
has been successfully executed on some replica yielding a return value $v$.
Note that the combination of $s$ and $i$ uniquely identifies the effect.
Session order relation ($\soZ$) relates effects generated by the same session.
An effect $\eff = (s,i,op,v)$ is said to precede another effect $\eff' =
(s',i',op',v')$ in session order if and only if $s'=s$ and $i'\ge i$. Since we
only consider one replicated object in our formalization, the $\sameobjZ$
relation relates every pair of effects in the effect soup ($\EffSoup$). An
effect generated at a replica becomes visible at rest of the replicas
eventually.  If we denote the effect generated by the operation $op$ as
$\eff_{op}$, then $\Theta(r) \times \{\eff_{op}\} ~\subseteq~ \visZ$. Often,
in our formalization, we use $\visZ$ and $\soZ$ binary relations to obtain a
set of effects visible to a given effect $\eff$, or set of effects that
precede a given effect $\eff$ in the session order. As a syntactic
convenience, whenever $R$ is a binary relation, we write $R(\eff)$ to denote
the set of all $\eff'$ such that $(\eff,\eff') \in R$.  Conversely, we write
$R^{-1}(\eff)$ to denote the set of all $\eff'$ such that $(\eff',\eff) \in
R$.  

Basic gurantee provided by the store is causal visibility, which is
captured by the rule $\rulelabel{EffVis}$ as a condition for an effect
to be visible at a replica. The rule makes an effect ($\eff$) visible
at a replica $r$ only after all the effects that causally precede
$\eff$ are made visible at $r$.  It is important to note that that
enforcing causal visibility does not require any inter-replica
coordination. Any eventually consistent store can provide causal
visibility while being eventually consistent.  Therefore, we do not lose
any generality by assuming that the store provides causal visiblity.

% Semantics
% ---------
\input{core-opsem}

Rule $\rulelabel{Oper}$ is an auxiliary reduction of the
form:\vspace{-1.7mm}
\begin{smathpar}
\auxred{\Theta} {(\E,\langle s,i,op \rangle)} {r} {(\E',\eff)}
\vspace{-1.7mm}
\end{smathpar}
\noindent Under the store configuration $\Theta$, the rule captures
the progress in execution (from $\E$ to $\E'$) due to the application
of operation $op$ to replica $r$ resulting in a new effect $\eff$.
The rule first constructs a \emph{context} for the application from
the local state ($\Theta(r)$) of the replica, by
projecting\footnote{{\textsf{ctxt*}} is auxiliary function
\textsf{ctxt} extended straightforwardly to set of effects} relevant
information from effects in $\Theta(r)$. It then substitutes the
definition ($\Ops(op)$) of the operation for its label ($op$), and
relies on the reduction relation ($\rdtredsto$) of the server-side
language to reduce the application $\Ops(op)(ctxt)$ to a value
$v'$.  Subsequently, the the attributes of execution state, namely
$\EffSoup$, $\visZ$, $\soZ$, and $\sameobjZ$ are extended to
incorporate the new effect ($\eff$). 

If the operation $op$ is {\sf EventuallyConsistent}, we simply apply
the operation to any replica $r$. Since the store provides causal
visibility, eventually consistent operations are satisfiable under any
replica. If the operation is {\sf CausallyConsistent}, the operation
can be applied to a replica $r$ only if it already contains the
effects of all the previous operations from the same session. This
guarantee can be satisfied by applying all operations from the same
session to the same logical copy of the database.  If such a logical
copy is untenable, then the operation might block. Since the store is
assumed to converge eventually, the blocked causally consistent
operation guaranteed to unblock eventually.

A {\sf StronglyConsistent} operation expects sequential consistency.
That is, universe of all effects ($\EffSoup$) in an execution ($\E$)
must be partitionable into a set of effects that \emph{happened
before} $\eff$ and another set that \emph{happened after} $\eff$,
where $\eff$ is the effect generated by an strongly consistent
operation. The rule $\rulelabel{UA}$ enforces this sequencing in two
steps; firstly, it insists that the the strongly consistent operation
($op$) witness effects of all operations executed so far by requiring
the global set of effects $\EffSoup$ to be a subset of local state
($\Theta(r)$) of the replica ($r$) executing $op$. Secondly, the rule
requires the effect ($\eff$) generated by $op$ to be added to the
local state of every other replica in the store, so that further
operations on these replicas can witness the effect of $op$. Since
both these steps require global coordination among replicas, the store
is \emph{unavailable} during the time it is executing $op$. 
% However, it must be noted that executing strongly consistent
% operation does not entail the convergence of local states of all
% replicas; it simply means that there is one replica ($r$) whose
% local state is the upper bound of local states of all replicas, and
% there exists a set containing atleast one effect ($\eff$), which is
% their lower bound.

\subsection{Soundness of Axiomatic Semantics}

Our main meta-theoretic result guarantees the soundness of our
axiomatic semantics in enforcing $\ecc$, $\ccc$, and $\scc$
consistency guarantess by ensuring that every reduction step preserves
correctness of axiomatic execution.

\begin{theorem}[Soundness preservation]
\label{lem:core-preservation}
Let $\E$ be a well-formed axiomatic execution state, and $\tau$ denote
a contract class.  If:
\begin{smathpar}
\E; \Theta; \langle s,i,\langle op,\tau \rangle;
\sigma \rangle \pll \Sigma \xhookrightarrow{\eff} \E'; \Theta';
\langle s,i,\sigma \rangle \Sigma'
\end{smathpar}
then (\romannumeral 1) $\E'$ is well-formed, and (\romannumeral 2)
$\E' \models \cv_{\tau}[\eff/\cureff]$ 
\end{theorem}
